import {
  customers,
  suppliers,
  items,
  enquiries,
  enquiryItems,
  quotations,
  quotationItems,
  salesOrders,
  salesOrderItems,
  supplierLpos,
  supplierLpoItems,
  goodsReceipts,
  deliveries,
  deliveryItems,
  invoices,
  invoiceItems,
  deliveryPickingSessions,
  deliveryPickedItems,
  creditNotes,
  creditNoteItems,
  legacyInventory,
  inventoryItems,
  inventoryVariants,
  inventoryLevels,
  goodsReceiptHeaders,
  goodsReceiptItems,
  scanningSessions,
  scannedItems,
  stockMovements,
  supplierReturns,
  supplierReturnItems,
  auditLog,
  users,
  customerAcceptances,
  purchaseOrders,
  quotationItemAcceptances,
  poLineItems,
  acceptanceConfirmations,
  approvalRules,
  quotationApprovals,
  productCategories,
  markupConfiguration,
  itemPricing,
  customerPricing,
  pricingRules,
  priceLists,
  priceListItems,
  priceChangeHistory,
  bulkPricingOperations,
  type Customer,
  type Supplier,
  type Item,
  type Enquiry,
  type EnquiryItem,
  type Quotation,
  type QuotationItem,
  type SalesOrder,
  type SalesOrderItem,
  type SupplierLpo,
  type SupplierLpoItem,
  type GoodsReceipt,
  type Delivery,
  type DeliveryItem,
  type Invoice,
  type InvoiceItem,
  type DeliveryPickingSession,
  type DeliveryPickedItem,
  type CreditNote,
  type CreditNoteItem,
  type User,
  type CustomerAcceptance,
  type PurchaseOrder,
  type QuotationItemAcceptance,
  type PoLineItem,
  type AcceptanceConfirmation,
  type ApprovalRule,
  type QuotationApproval,
  type InventoryItem,
  type InventoryVariant,
  type Inventory,
  type GoodsReceiptHeader,
  type GoodsReceiptItem,
  type ScanningSession,
  type ScannedItem,
  type SupplierReturn,
  type SupplierReturnItem,
  type StockMovement,
  type InsertCustomer,
  type InsertSupplier,
  type InsertItem,
  type InsertEnquiry,
  type InsertEnquiryItem,
  type InsertQuotation,
  type InsertQuotationItem,
  type InsertApprovalRule,
  type InsertQuotationApproval,
  type InsertCustomerAcceptance,
  type InsertPurchaseOrder,
  type InsertQuotationItemAcceptance,
  type InsertPoLineItem,
  type InsertAcceptanceConfirmation,
  type InsertSalesOrder,
  type InsertSalesOrderItem,
  type InsertSupplierLpo,
  type InsertSupplierLpoItem,
  type InsertInventoryItem,
  type InsertInventoryVariant,
  type InsertInventory,
  type InsertGoodsReceiptHeader,
  type InsertGoodsReceiptItem,
  type InsertScanningSession,
  type InsertScannedItem,
  type InsertSupplierReturn,
  type InsertSupplierReturnItem,
  type InsertStockMovement,
  type InsertDelivery,
  type InsertDeliveryItem,
  type InsertInvoiceItem,
  type InsertDeliveryPickingSession,
  type InsertDeliveryPickedItem,
  type InsertCreditNote,
  type InsertCreditNoteItem,
  type InsertInvoice,
  type ProductCategory,
  type MarkupConfiguration,
  type ItemPricing,
  type CustomerPricing,
  type PricingRule,
  type PriceList,
  type PriceListItem,
  type PriceChangeHistory,
  type BulkPricingOperation,
  type InsertProductCategory,
  type InsertMarkupConfiguration,
  type InsertItemPricing,
  type InsertCustomerPricing,
  type InsertPricingRule,
  type InsertPriceList,
  type InsertPriceListItem,
  type InsertPriceChangeHistory,
  type InsertBulkPricingOperation,
} from "@shared/schema";
import { db } from "./db";
import { eq, desc, and, or, like, count, sql, inArray } from "drizzle-orm";

export interface IStorage {
  // User operations
  getUser(id: string): Promise<User | undefined>;
  createUser(user: Omit<User, "id" | "createdAt" | "updatedAt">): Promise<User>;

  // Customer operations
  getCustomers(limit?: number, offset?: number): Promise<Customer[]>;
  getCustomer(id: string): Promise<Customer | undefined>;
  createCustomer(customer: InsertCustomer): Promise<Customer>;
  updateCustomer(id: string, customer: Partial<InsertCustomer>): Promise<Customer>;

  // Supplier operations
  getSuppliers(): Promise<Supplier[]>;
  getSupplier(id: string): Promise<Supplier | undefined>;
  createSupplier(supplier: InsertSupplier): Promise<Supplier>;

  // Item operations
  getItems(): Promise<Item[]>;
  getItem(id: string): Promise<Item | undefined>;
  getItemByBarcode(barcode: string): Promise<Item | undefined>;
  createItem(item: InsertItem): Promise<Item>;

  // Enquiry operations
  getEnquiries(limit?: number, offset?: number, filters?: {
    status?: string;
    source?: string;
    customerId?: string;
    dateFrom?: string;
    dateTo?: string;
    search?: string;
  }): Promise<Enquiry[]>;
  getEnquiry(id: string): Promise<Enquiry | undefined>;
  createEnquiry(enquiry: InsertEnquiry): Promise<Enquiry>;
  updateEnquiry(id: string, enquiry: Partial<InsertEnquiry>): Promise<Enquiry>;
  deleteEnquiry(id: string): Promise<void>;
  
  // Enquiry Item operations
  getEnquiryItems(enquiryId: string): Promise<EnquiryItem[]>;
  getEnquiryItem(id: string): Promise<EnquiryItem | undefined>;
  createEnquiryItem(enquiryItem: InsertEnquiryItem): Promise<EnquiryItem>;
  updateEnquiryItem(id: string, enquiryItem: Partial<InsertEnquiryItem>): Promise<EnquiryItem>;
  deleteEnquiryItem(id: string): Promise<void>;
  bulkCreateEnquiryItems(enquiryItems: InsertEnquiryItem[]): Promise<EnquiryItem[]>;

  // Quotation operations
  getQuotations(limit?: number, offset?: number, filters?: {
    status?: string;
    customerId?: string;
    dateFrom?: string;
    dateTo?: string;
    search?: string;
  }): Promise<Quotation[]>;
  getQuotation(id: string): Promise<Quotation | undefined>;
  createQuotation(quotation: InsertQuotation): Promise<Quotation>;
  updateQuotation(id: string, quotation: Partial<InsertQuotation>): Promise<Quotation>;
  deleteQuotation(id: string): Promise<void>;
  generateQuotationFromEnquiry(enquiryId: string, userId: string): Promise<Quotation>;
  
  // Quotation revision operations
  createQuotationRevision(originalId: string, revisionData: any, userId: string): Promise<Quotation>;
  getQuotationRevisions(originalId: string): Promise<Quotation[]>;
  getQuotationHistory(quotationId: string): Promise<any[]>;

  // Quotation Item operations
  getQuotationItems(quotationId: string): Promise<QuotationItem[]>;
  createQuotationItem(item: InsertQuotationItem): Promise<QuotationItem>;
  updateQuotationItem(id: string, item: Partial<InsertQuotationItem>): Promise<QuotationItem>;
  deleteQuotationItem(id: string): Promise<void>;

  // Approval operations
  getApprovalRules(): Promise<ApprovalRule[]>;
  createApprovalRule(rule: InsertApprovalRule): Promise<ApprovalRule>;
  updateApprovalRule(id: string, rule: Partial<InsertApprovalRule>): Promise<ApprovalRule>;
  deleteApprovalRule(id: string): Promise<void>;
  determineRequiredApprovalLevel(quotation: Partial<Quotation>): Promise<string | null>;

  getQuotationApprovals(quotationId: string): Promise<QuotationApproval[]>;
  createQuotationApproval(approval: InsertQuotationApproval): Promise<QuotationApproval>;

  // Customer Acceptance operations
  getCustomerAcceptances(quotationId?: string): Promise<CustomerAcceptance[]>;
  getCustomerAcceptance(id: string): Promise<CustomerAcceptance | undefined>;
  createCustomerAcceptance(acceptance: InsertCustomerAcceptance): Promise<CustomerAcceptance>;
  updateCustomerAcceptance(id: string, acceptance: Partial<InsertCustomerAcceptance>): Promise<CustomerAcceptance>;
  deleteCustomerAcceptance(id: string): Promise<void>;

  // Purchase Order operations
  getPurchaseOrders(quotationId?: string): Promise<PurchaseOrder[]>;
  getPurchaseOrder(id: string): Promise<PurchaseOrder | undefined>;
  createPurchaseOrder(po: InsertPurchaseOrder): Promise<PurchaseOrder>;
  updatePurchaseOrder(id: string, po: Partial<InsertPurchaseOrder>): Promise<PurchaseOrder>;
  deletePurchaseOrder(id: string): Promise<void>;
  validatePurchaseOrder(id: string, validationData: { status: string; notes?: string; validatedBy: string }): Promise<PurchaseOrder>;

  // Quotation Item Acceptance operations
  getQuotationItemAcceptances(customerAcceptanceId: string): Promise<QuotationItemAcceptance[]>;
  getQuotationItemAcceptance(id: string): Promise<QuotationItemAcceptance | undefined>;
  createQuotationItemAcceptance(itemAcceptance: InsertQuotationItemAcceptance): Promise<QuotationItemAcceptance>;
  updateQuotationItemAcceptance(id: string, itemAcceptance: Partial<InsertQuotationItemAcceptance>): Promise<QuotationItemAcceptance>;
  bulkCreateQuotationItemAcceptances(itemAcceptances: InsertQuotationItemAcceptance[]): Promise<QuotationItemAcceptance[]>;

  // PO Line Items operations
  getPoLineItems(purchaseOrderId: string): Promise<PoLineItem[]>;
  createPoLineItem(lineItem: InsertPoLineItem): Promise<PoLineItem>;
  updatePoLineItem(id: string, lineItem: Partial<InsertPoLineItem>): Promise<PoLineItem>;
  bulkCreatePoLineItems(lineItems: InsertPoLineItem[]): Promise<PoLineItem[]>;

  // Acceptance Confirmation operations
  getAcceptanceConfirmations(customerAcceptanceId: string): Promise<AcceptanceConfirmation[]>;
  createAcceptanceConfirmation(confirmation: InsertAcceptanceConfirmation): Promise<AcceptanceConfirmation>;

  // Sales Order operations
  getSalesOrders(limit?: number, offset?: number, filters?: {
    status?: string;
    customerId?: string;
    dateFrom?: string;
    dateTo?: string;
    search?: string;
  }): Promise<SalesOrder[]>;
  getSalesOrder(id: string): Promise<SalesOrder | undefined>;
  createSalesOrder(salesOrder: InsertSalesOrder): Promise<SalesOrder>;
  updateSalesOrder(id: string, salesOrder: Partial<InsertSalesOrder>): Promise<SalesOrder>;
  deleteSalesOrder(id: string): Promise<void>;
  createSalesOrderFromQuotation(quotationId: string, customerAcceptanceId?: string, userId?: string): Promise<SalesOrder>;
  createAmendedSalesOrder(parentOrderId: string, reason: string, userId?: string): Promise<SalesOrder>;
  validateCustomerLpo(id: string, validationData: { status: string; notes?: string; validatedBy: string }): Promise<SalesOrder>;
  
  // Sales Order Item operations
  getSalesOrderItems(salesOrderId: string): Promise<SalesOrderItem[]>;
  getSalesOrderItem(id: string): Promise<SalesOrderItem | undefined>;
  createSalesOrderItem(item: InsertSalesOrderItem): Promise<SalesOrderItem>;
  updateSalesOrderItem(id: string, item: Partial<InsertSalesOrderItem>): Promise<SalesOrderItem>;
  deleteSalesOrderItem(id: string): Promise<void>;
  bulkCreateSalesOrderItems(items: InsertSalesOrderItem[]): Promise<SalesOrderItem[]>;

  // Supplier LPO operations
  getSupplierLpos(limit?: number, offset?: number, filters?: {
    status?: string;
    supplierId?: string;
    dateFrom?: string;
    dateTo?: string;
    search?: string;
  }): Promise<SupplierLpo[]>;
  getSupplierLpo(id: string): Promise<SupplierLpo | undefined>;
  createSupplierLpo(supplierLpo: InsertSupplierLpo): Promise<SupplierLpo>;
  updateSupplierLpo(id: string, supplierLpo: Partial<InsertSupplierLpo>): Promise<SupplierLpo>;
  deleteSupplierLpo(id: string): Promise<void>;
  createSupplierLposFromSalesOrders(salesOrderIds: string[], groupBy: string, userId?: string): Promise<SupplierLpo[]>;
  createAmendedSupplierLpo(parentLpoId: string, reason: string, amendmentType: string, userId?: string): Promise<SupplierLpo>;
  submitForApproval(id: string, userId: string): Promise<SupplierLpo>;
  approveSupplierLpo(id: string, userId: string, notes?: string): Promise<SupplierLpo>;
  rejectSupplierLpo(id: string, userId: string, notes: string): Promise<SupplierLpo>;
  sendToSupplier(id: string, userId: string): Promise<SupplierLpo>;
  confirmBySupplier(id: string, confirmationReference?: string): Promise<SupplierLpo>;
  getSupplierLpoBacklog(): Promise<any[]>;
  getCustomerOrderBacklog(): Promise<any[]>;
  
  // Supplier LPO Item operations
  getSupplierLpoItems(supplierLpoId: string): Promise<SupplierLpoItem[]>;
  getSupplierLpoItem(id: string): Promise<SupplierLpoItem | undefined>;
  createSupplierLpoItem(item: InsertSupplierLpoItem): Promise<SupplierLpoItem>;
  updateSupplierLpoItem(id: string, item: Partial<InsertSupplierLpoItem>): Promise<SupplierLpoItem>;
  deleteSupplierLpoItem(id: string): Promise<void>;
  bulkCreateSupplierLpoItems(items: InsertSupplierLpoItem[]): Promise<SupplierLpoItem[]>;

  // Inventory Item operations
  getInventoryItems(filters?: {
    search?: string;
    supplierId?: string;
    category?: string;
    isActive?: boolean;
    limit?: number;
    offset?: number;
  }): Promise<InventoryItem[]>;
  getInventoryItem(id: string): Promise<InventoryItem | undefined>;
  getInventoryItemBySupplierCode(supplierCode: string): Promise<InventoryItem | undefined>;
  getInventoryItemByBarcode(barcode: string): Promise<InventoryItem | undefined>;
  createInventoryItem(item: InsertInventoryItem): Promise<InventoryItem>;
  updateInventoryItem(id: string, item: Partial<InsertInventoryItem>): Promise<InventoryItem>;
  deleteInventoryItem(id: string): Promise<void>;
  bulkCreateInventoryItems(items: InsertInventoryItem[]): Promise<InventoryItem[]>;

  // Item Variant operations (using InventoryVariant for now)
  getItemVariants(itemId: string): Promise<InventoryVariant[]>;
  getItemVariant(id: string): Promise<InventoryVariant | undefined>;
  createItemVariant(variant: InsertInventoryVariant): Promise<InventoryVariant>;
  updateItemVariant(id: string, variant: Partial<InsertInventoryVariant>): Promise<InventoryVariant>;
  deleteItemVariant(id: string): Promise<void>;

  // Inventory operations (stock levels)
  getInventoryLevels(filters?: {
    itemId?: string;
    location?: string;
    lowStock?: boolean;
  }): Promise<InventoryLevel[]>;
  getInventoryLevel(id: string): Promise<InventoryLevel | undefined>;
  getInventoryLevelByItem(itemId: string, location?: string): Promise<InventoryLevel | undefined>;
  createInventoryLevel(inventory: InsertInventoryLevel): Promise<InventoryLevel>;
  updateInventoryLevel(id: string, inventory: Partial<InsertInventoryLevel>): Promise<InventoryLevel>;
  deleteInventoryLevel(id: string): Promise<void>;
  adjustInventoryQuantity(itemId: string, quantityChange: number, location?: string, reason?: string): Promise<InventoryLevel>;

  // Goods Receipt Header operations
  getGoodsReceiptHeaders(filters?: {
    status?: string;
    supplierLpoId?: string;
    dateFrom?: string;
    dateTo?: string;
    limit?: number;
    offset?: number;
  }): Promise<GoodsReceiptHeader[]>;
  getGoodsReceiptHeader(id: string): Promise<GoodsReceiptHeader | undefined>;
  getGoodsReceiptByNumber(receiptNumber: string): Promise<GoodsReceiptHeader | undefined>;
  createGoodsReceiptHeader(receipt: InsertGoodsReceiptHeader): Promise<GoodsReceiptHeader>;
  updateGoodsReceiptHeader(id: string, receipt: Partial<InsertGoodsReceiptHeader>): Promise<GoodsReceiptHeader>;
  deleteGoodsReceiptHeader(id: string): Promise<void>;

  // Goods Receipt Item operations
  getGoodsReceiptItems(goodsReceiptId: string): Promise<GoodsReceiptItem[]>;
  getGoodsReceiptItem(id: string): Promise<GoodsReceiptItem | undefined>;
  createGoodsReceiptItem(item: InsertGoodsReceiptItem): Promise<GoodsReceiptItem>;
  updateGoodsReceiptItem(id: string, item: Partial<InsertGoodsReceiptItem>): Promise<GoodsReceiptItem>;
  deleteGoodsReceiptItem(id: string): Promise<void>;
  bulkCreateGoodsReceiptItems(items: InsertGoodsReceiptItem[]): Promise<GoodsReceiptItem[]>;

  // Scanning Session operations
  getScanningSessions(filters?: {
    status?: string;
    goodsReceiptId?: string;
    dateFrom?: string;
    dateTo?: string;
  }): Promise<ScanningSession[]>;
  getScanningSession(id: string): Promise<ScanningSession | undefined>;
  createScanningSession(session: InsertScanningSession): Promise<ScanningSession>;
  updateScanningSession(id: string, session: Partial<InsertScanningSession>): Promise<ScanningSession>;
  deleteScanningSession(id: string): Promise<void>;

  // Scanned Item operations
  getScannedItems(scanningSessionId: string): Promise<ScannedItem[]>;
  getScannedItem(id: string): Promise<ScannedItem | undefined>;
  createScannedItem(item: InsertScannedItem): Promise<ScannedItem>;
  updateScannedItem(id: string, item: Partial<InsertScannedItem>): Promise<ScannedItem>;
  deleteScannedItem(id: string): Promise<void>;
  bulkCreateScannedItems(items: InsertScannedItem[]): Promise<ScannedItem[]>;

  // Supplier Return operations
  getSupplierReturns(filters?: {
    status?: string;
    supplierId?: string;
    dateFrom?: string;
    dateTo?: string;
    limit?: number;
    offset?: number;
  }): Promise<SupplierReturn[]>;
  getSupplierReturn(id: string): Promise<SupplierReturn | undefined>;
  getSupplierReturnByNumber(returnNumber: string): Promise<SupplierReturn | undefined>;
  createSupplierReturn(supplierReturn: InsertSupplierReturn): Promise<SupplierReturn>;
  updateSupplierReturn(id: string, supplierReturn: Partial<InsertSupplierReturn>): Promise<SupplierReturn>;
  deleteSupplierReturn(id: string): Promise<void>;

  // Supplier Return Item operations
  getSupplierReturnItems(supplierReturnId: string): Promise<SupplierReturnItem[]>;
  getSupplierReturnItem(id: string): Promise<SupplierReturnItem | undefined>;
  createSupplierReturnItem(item: InsertSupplierReturnItem): Promise<SupplierReturnItem>;
  updateSupplierReturnItem(id: string, item: Partial<InsertSupplierReturnItem>): Promise<SupplierReturnItem>;
  deleteSupplierReturnItem(id: string): Promise<void>;
  bulkCreateSupplierReturnItems(items: InsertSupplierReturnItem[]): Promise<SupplierReturnItem[]>;

  // Stock Movement operations
  getStockMovements(filters?: {
    itemId?: string;
    movementType?: string;
    referenceType?: string;
    referenceId?: string;
    dateFrom?: string;
    dateTo?: string;
    limit?: number;
    offset?: number;
  }): Promise<StockMovement[]>;
  getStockMovement(id: string): Promise<StockMovement | undefined>;
  createStockMovement(movement: InsertStockMovement): Promise<StockMovement>;
  getItemStockHistory(itemId: string, limit?: number): Promise<StockMovement[]>;

  // Dashboard statistics
  getDashboardStats(): Promise<{
    activeEnquiries: number;
    pendingQuotes: number;
    activeOrders: number;
    monthlyRevenue: number;
  }>;

  // Delivery operations
  getDeliveries(filters?: {
    status?: string;
    salesOrderId?: string;
    dateFrom?: string;
    dateTo?: string;
    limit?: number;
    offset?: number;
  }): Promise<Delivery[]>;
  getDelivery(id: string): Promise<Delivery | undefined>;
  getDeliveryByNumber(deliveryNumber: string): Promise<Delivery | undefined>;
  createDelivery(delivery: InsertDelivery): Promise<Delivery>;
  updateDelivery(id: string, delivery: Partial<InsertDelivery>): Promise<Delivery>;
  deleteDelivery(id: string): Promise<void>;
  startDeliveryPicking(deliveryId: string, userId: string): Promise<Delivery>;
  completeDeliveryPicking(deliveryId: string, userId: string, notes?: string): Promise<Delivery>;
  confirmDelivery(deliveryId: string, confirmedBy: string, signature?: string): Promise<Delivery>;

  // Delivery Item operations
  getDeliveryItems(deliveryId: string): Promise<DeliveryItem[]>;
  getDeliveryItem(id: string): Promise<DeliveryItem | undefined>;
  createDeliveryItem(item: InsertDeliveryItem): Promise<DeliveryItem>;
  updateDeliveryItem(id: string, item: Partial<InsertDeliveryItem>): Promise<DeliveryItem>;
  deleteDeliveryItem(id: string): Promise<void>;
  bulkCreateDeliveryItems(items: InsertDeliveryItem[]): Promise<DeliveryItem[]>;

  // Delivery Picking Session operations
  getDeliveryPickingSessions(deliveryId: string): Promise<DeliveryPickingSession[]>;
  getDeliveryPickingSession(id: string): Promise<DeliveryPickingSession | undefined>;
  createDeliveryPickingSession(session: InsertDeliveryPickingSession): Promise<DeliveryPickingSession>;
  updateDeliveryPickingSession(id: string, session: Partial<InsertDeliveryPickingSession>): Promise<DeliveryPickingSession>;
  completePickingSession(sessionId: string): Promise<DeliveryPickingSession>;

  // Delivery Picked Item operations
  getDeliveryPickedItems(sessionId: string): Promise<DeliveryPickedItem[]>;
  getDeliveryPickedItem(id: string): Promise<DeliveryPickedItem | undefined>;
  createDeliveryPickedItem(item: InsertDeliveryPickedItem): Promise<DeliveryPickedItem>;
  updateDeliveryPickedItem(id: string, item: Partial<InsertDeliveryPickedItem>): Promise<DeliveryPickedItem>;
  verifyPickedItem(itemId: string, userId: string): Promise<DeliveryPickedItem>;

  // Invoice operations
  getInvoices(filters?: {
    status?: string;
    type?: string;
    customerId?: string;
    salesOrderId?: string;
    dateFrom?: string;
    dateTo?: string;
    currency?: string;
    limit?: number;
    offset?: number;
  }): Promise<Invoice[]>;
  getInvoice(id: string): Promise<Invoice | undefined>;
  getInvoiceByNumber(invoiceNumber: string): Promise<Invoice | undefined>;
  createInvoice(invoice: InsertInvoice): Promise<Invoice>;
  updateInvoice(id: string, invoice: Partial<InsertInvoice>): Promise<Invoice>;
  deleteInvoice(id: string): Promise<void>;
  generateInvoiceFromDelivery(deliveryId: string, invoiceType?: string, userId?: string): Promise<Invoice>;
  generateProformaInvoice(salesOrderId: string, userId?: string): Promise<Invoice>;
  sendInvoice(invoiceId: string, userId: string): Promise<Invoice>;
  markInvoicePaid(invoiceId: string, paidAmount: number, paymentMethod?: string, paymentReference?: string, userId?: string): Promise<Invoice>;

  // Invoice Item operations
  getInvoiceItems(invoiceId: string): Promise<InvoiceItem[]>;
  getInvoiceItem(id: string): Promise<InvoiceItem | undefined>;
  createInvoiceItem(item: InsertInvoiceItem): Promise<InvoiceItem>;
  updateInvoiceItem(id: string, item: Partial<InsertInvoiceItem>): Promise<InvoiceItem>;
  deleteInvoiceItem(id: string): Promise<void>;
  bulkCreateInvoiceItems(items: InsertInvoiceItem[]): Promise<InvoiceItem[]>;

  // Credit Note operations
  getCreditNotes(filters?: {
    status?: string;
    customerId?: string;
    originalInvoiceId?: string;
    dateFrom?: string;
    dateTo?: string;
    limit?: number;
    offset?: number;
  }): Promise<CreditNote[]>;
  getCreditNote(id: string): Promise<CreditNote | undefined>;
  getCreditNoteByNumber(creditNoteNumber: string): Promise<CreditNote | undefined>;
  createCreditNote(creditNote: InsertCreditNote): Promise<CreditNote>;
  updateCreditNote(id: string, creditNote: Partial<InsertCreditNote>): Promise<CreditNote>;
  deleteCreditNote(id: string): Promise<void>;
  generateCreditNoteFromReturn(invoiceId: string, returnItems: any[], reason: string, userId?: string): Promise<CreditNote>;
  applyCreditNote(creditNoteId: string, appliedAmount: number, userId: string): Promise<CreditNote>;

  // Credit Note Item operations
  getCreditNoteItems(creditNoteId: string): Promise<CreditNoteItem[]>;
  getCreditNoteItem(id: string): Promise<CreditNoteItem | undefined>;
  createCreditNoteItem(item: InsertCreditNoteItem): Promise<CreditNoteItem>;
  updateCreditNoteItem(id: string, item: Partial<InsertCreditNoteItem>): Promise<CreditNoteItem>;
  deleteCreditNoteItem(id: string): Promise<void>;
  bulkCreateCreditNoteItems(items: InsertCreditNoteItem[]): Promise<CreditNoteItem[]>;

  // Barcode scanning and verification
  verifyItemBarcode(barcode: string, expectedItemId?: string): Promise<{ valid: boolean; item?: any; message: string }>;
  scanItemForPicking(barcode: string, sessionId: string, quantity: number, userId: string, storageLocation?: string): Promise<DeliveryPickedItem>;
  getAvailableItemsForPicking(deliveryId: string): Promise<any[]>;
  
  // Multi-currency operations
  convertCurrency(amount: number, fromCurrency: string, toCurrency: string, exchangeRate?: number): Promise<number>;
  getExchangeRate(fromCurrency: string, toCurrency: string): Promise<number>;
  updateInvoiceCurrency(invoiceId: string, newCurrency: string, exchangeRate: number, userId: string): Promise<Invoice>;

  // Audit operations
  logAuditEvent(
    entityType: string,
    entityId: string,
    action: string,
    userId?: string,
    oldData?: any,
    newData?: any
  ): Promise<void>;
}

export class DatabaseStorage implements IStorage {
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async createUser(userData: Omit<User, "id" | "createdAt" | "updatedAt">): Promise<User> {
    const [user] = await db.insert(users).values(userData).returning();
    return user;
  }

  async getCustomers(limit = 50, offset = 0): Promise<Customer[]> {
    return db
      .select()
      .from(customers)
      .where(eq(customers.isActive, true))
      .limit(limit)
      .offset(offset)
      .orderBy(desc(customers.createdAt));
  }

  async getCustomer(id: string): Promise<Customer | undefined> {
    const [customer] = await db.select().from(customers).where(eq(customers.id, id));
    return customer;
  }

  async createCustomer(customerData: InsertCustomer): Promise<Customer> {
    const [customer] = await db.insert(customers).values(customerData).returning();
    await this.logAuditEvent("customer", customer.id, "create", undefined, undefined, customer);
    return customer;
  }

  async updateCustomer(id: string, customerData: Partial<InsertCustomer>): Promise<Customer> {
    const oldCustomer = await this.getCustomer(id);
    const [customer] = await db
      .update(customers)
      .set({ ...customerData, updatedAt: new Date() })
      .where(eq(customers.id, id))
      .returning();
    
    await this.logAuditEvent("customer", id, "update", undefined, oldCustomer, customer);
    return customer;
  }

  async getSuppliers(): Promise<Supplier[]> {
    return db
      .select()
      .from(suppliers)
      .where(eq(suppliers.isActive, true))
      .orderBy(desc(suppliers.createdAt));
  }

  async getSupplier(id: string): Promise<Supplier | undefined> {
    const [supplier] = await db.select().from(suppliers).where(eq(suppliers.id, id));
    return supplier;
  }

  async createSupplier(supplierData: InsertSupplier): Promise<Supplier> {
    const [supplier] = await db.insert(suppliers).values(supplierData).returning();
    await this.logAuditEvent("supplier", supplier.id, "create", undefined, undefined, supplier);
    return supplier;
  }

  async getItems(): Promise<Item[]> {
    return db
      .select()
      .from(items)
      .where(eq(items.isActive, true))
      .orderBy(desc(items.createdAt));
  }

  async getItem(id: string): Promise<Item | undefined> {
    const [item] = await db.select().from(items).where(eq(items.id, id));
    return item;
  }

  async getItemByBarcode(barcode: string): Promise<Item | undefined> {
    const [item] = await db.select().from(items).where(eq(items.barcode, barcode));
    return item;
  }

  async createItem(itemData: InsertItem): Promise<Item> {
    const [item] = await db.insert(items).values(itemData).returning();
    await this.logAuditEvent("item", item.id, "create", undefined, undefined, item);
    return item;
  }

  async getEnquiries(limit = 50, offset = 0, filters?: {
    status?: string;
    source?: string;
    customerId?: string;
    dateFrom?: string;
    dateTo?: string;
    search?: string;
  }): Promise<Enquiry[]> {
    let query = db.select().from(enquiries);
    
    const conditions = [];
    
    if (filters?.status) {
      conditions.push(eq(enquiries.status, filters.status as any));
    }
    
    if (filters?.source) {
      conditions.push(eq(enquiries.source, filters.source as any));
    }
    
    if (filters?.customerId) {
      conditions.push(eq(enquiries.customerId, filters.customerId));
    }
    
    if (filters?.dateFrom) {
      conditions.push(sql`${enquiries.enquiryDate} >= ${filters.dateFrom}`);
    }
    
    if (filters?.dateTo) {
      conditions.push(sql`${enquiries.enquiryDate} <= ${filters.dateTo}`);
    }
    
    if (filters?.search) {
      conditions.push(
        or(
          like(enquiries.enquiryNumber, `%${filters.search}%`),
          like(enquiries.notes, `%${filters.search}%`)
        )
      );
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    return query
      .limit(limit)
      .offset(offset)
      .orderBy(desc(enquiries.createdAt));
  }

  async getEnquiry(id: string): Promise<Enquiry | undefined> {
    const [enquiry] = await db.select().from(enquiries).where(eq(enquiries.id, id));
    return enquiry;
  }

  async createEnquiry(enquiryData: InsertEnquiry): Promise<Enquiry> {
    // Generate enquiry number
    const enquiryCount = await db.select({ count: count() }).from(enquiries);
    const enquiryNumber = `ENQ-2024-${String(enquiryCount[0].count + 1).padStart(3, '0')}`;
    
    // Convert date string to Date object if provided
    const processedData = {
      ...enquiryData,
      targetDeliveryDate: enquiryData.targetDeliveryDate ? new Date(enquiryData.targetDeliveryDate) : null,
      enquiryNumber
    };
    
    const [enquiry] = await db
      .insert(enquiries)
      .values(processedData)
      .returning();
    
    await this.logAuditEvent("enquiry", enquiry.id, "create", enquiryData.createdBy || undefined, undefined, enquiry);
    return enquiry;
  }

  async updateEnquiry(id: string, enquiryData: Partial<InsertEnquiry>): Promise<Enquiry> {
    const oldEnquiry = await this.getEnquiry(id);
    
    // Convert date string to Date object if provided
    const processedData = {
      ...enquiryData,
      targetDeliveryDate: enquiryData.targetDeliveryDate ? new Date(enquiryData.targetDeliveryDate) : enquiryData.targetDeliveryDate,
      updatedAt: new Date()
    };
    
    const [enquiry] = await db
      .update(enquiries)
      .set(processedData)
      .where(eq(enquiries.id, id))
      .returning();
    
    await this.logAuditEvent("enquiry", id, "update", undefined, oldEnquiry, enquiry);
    return enquiry;
  }

  async deleteEnquiry(id: string): Promise<void> {
    const enquiry = await this.getEnquiry(id);
    
    // First delete all enquiry items
    await db.delete(enquiryItems).where(eq(enquiryItems.enquiryId, id));
    
    // Then delete the enquiry
    await db.delete(enquiries).where(eq(enquiries.id, id));
    
    await this.logAuditEvent("enquiry", id, "delete", undefined, enquiry, undefined);
  }

  async getEnquiryItems(enquiryId: string): Promise<EnquiryItem[]> {
    return db.select().from(enquiryItems).where(eq(enquiryItems.enquiryId, enquiryId));
  }

  async getEnquiryItem(id: string): Promise<EnquiryItem | undefined> {
    const [item] = await db.select().from(enquiryItems).where(eq(enquiryItems.id, id));
    return item;
  }

  async createEnquiryItem(enquiryItemData: InsertEnquiryItem): Promise<EnquiryItem> {
    const [enquiryItem] = await db
      .insert(enquiryItems)
      .values(enquiryItemData)
      .returning();
    
    await this.logAuditEvent("enquiry_item", enquiryItem.id, "create", undefined, undefined, enquiryItem);
    return enquiryItem;
  }

  async updateEnquiryItem(id: string, enquiryItemData: Partial<InsertEnquiryItem>): Promise<EnquiryItem> {
    const oldItem = await this.getEnquiryItem(id);
    const [enquiryItem] = await db
      .update(enquiryItems)
      .set(enquiryItemData)
      .where(eq(enquiryItems.id, id))
      .returning();
    
    await this.logAuditEvent("enquiry_item", id, "update", undefined, oldItem, enquiryItem);
    return enquiryItem;
  }

  async deleteEnquiryItem(id: string): Promise<void> {
    const item = await this.getEnquiryItem(id);
    await db.delete(enquiryItems).where(eq(enquiryItems.id, id));
    
    await this.logAuditEvent("enquiry_item", id, "delete", undefined, item, undefined);
  }

  async bulkCreateEnquiryItems(enquiryItemsData: InsertEnquiryItem[]): Promise<EnquiryItem[]> {
    if (enquiryItemsData.length === 0) return [];
    
    const items = await db
      .insert(enquiryItems)
      .values(enquiryItemsData)
      .returning();
    
    // Log audit events for bulk creation
    for (const item of items) {
      await this.logAuditEvent("enquiry_item", item.id, "create", undefined, undefined, item);
    }
    
    return items;
  }

  async getQuotations(limit = 50, offset = 0, filters?: {
    status?: string;
    customerId?: string;
    dateFrom?: string;
    dateTo?: string;
    search?: string;
  }): Promise<Quotation[]> {
    let query = db.select().from(quotations);
    
    if (filters) {
      const conditions = [];
      
      if (filters.status) {
        conditions.push(eq(quotations.status, filters.status as any));
      }
      
      if (filters.customerId) {
        conditions.push(eq(quotations.customerId, filters.customerId));
      }
      
      if (filters.search) {
        conditions.push(
          or(
            like(quotations.quoteNumber, `%${filters.search}%`),
            like(quotations.notes, `%${filters.search}%`)
          )
        );
      }
      
      if (filters.dateFrom) {
        conditions.push(eq(quotations.quoteDate, filters.dateFrom));
      }
      
      if (conditions.length > 0) {
        query = query.where(and(...conditions));
      }
    }
    
    return query
      .limit(limit)
      .offset(offset)
      .orderBy(desc(quotations.createdAt));
  }

  async getQuotation(id: string): Promise<Quotation | undefined> {
    const [quotation] = await db.select().from(quotations).where(eq(quotations.id, id));
    return quotation;
  }

  async createQuotation(quotationData: InsertQuotation): Promise<Quotation> {
    // Generate quote number
    const quoteCount = await db.select({ count: count() }).from(quotations);
    const quoteNumber = `QT-2024-${String(quoteCount[0].count + 1).padStart(3, '0')}`;
    
    const [quotation] = await db
      .insert(quotations)
      .values({ ...quotationData, quoteNumber })
      .returning();
    
    await this.logAuditEvent("quotation", quotation.id, "create", quotationData.createdBy || undefined, undefined, quotation);
    return quotation;
  }

  async updateQuotation(id: string, quotationData: Partial<InsertQuotation>): Promise<Quotation> {
    const oldQuotation = await this.getQuotation(id);
    const [quotation] = await db
      .update(quotations)
      .set({ ...quotationData, updatedAt: new Date() })
      .where(eq(quotations.id, id))
      .returning();
    
    await this.logAuditEvent("quotation", id, "update", undefined, oldQuotation, quotation);
    return quotation;
  }

  async deleteQuotation(id: string): Promise<void> {
    const oldQuotation = await this.getQuotation(id);
    await db.delete(quotations).where(eq(quotations.id, id));
    await this.logAuditEvent("quotation", id, "delete", undefined, oldQuotation, undefined);
  }

  async createQuotationRevision(originalId: string, revisionData: any, userId: string): Promise<Quotation> {
    // Get the original quotation
    const originalQuotation = await this.getQuotation(originalId);
    if (!originalQuotation) {
      throw new Error("Original quotation not found");
    }

    // Get the original quotation items
    const originalItems = await this.getQuotationItems(originalId);

    // Mark the original quotation as superseded
    await db.update(quotations)
      .set({ 
        isSuperseded: true, 
        supersededAt: new Date(),
        supersededBy: userId 
      })
      .where(eq(quotations.id, originalId));

    // Create new revision with incremented revision number
    const newRevision = originalQuotation.revision + 1;
    
    // Create the new quotation revision
    const [newQuotation] = await db.insert(quotations).values({
      quoteNumber: originalQuotation.quoteNumber,
      revision: newRevision,
      parentQuotationId: originalId,
      revisionReason: revisionData.revisionReason,
      enquiryId: originalQuotation.enquiryId,
      customerId: originalQuotation.customerId,
      customerType: originalQuotation.customerType,
      status: "Draft", // New revisions start as Draft
      quoteDate: revisionData.quoteDate ? new Date(revisionData.quoteDate) : new Date(),
      validUntil: revisionData.validUntil ? new Date(revisionData.validUntil) : originalQuotation.validUntil,
      subtotal: revisionData.subtotal || originalQuotation.subtotal,
      discountPercentage: revisionData.discountPercentage || originalQuotation.discountPercentage,
      discountAmount: revisionData.discountAmount || originalQuotation.discountAmount,
      taxAmount: revisionData.taxAmount || originalQuotation.taxAmount,
      totalAmount: revisionData.totalAmount || originalQuotation.totalAmount,
      terms: revisionData.terms || originalQuotation.terms,
      notes: revisionData.notes || originalQuotation.notes,
      approvalStatus: "Pending",
      requiredApprovalLevel: originalQuotation.requiredApprovalLevel,
      createdBy: userId,
    }).returning();

    // Copy items to new revision (modified if provided)
    if (revisionData.items && revisionData.items.length > 0) {
      // Use provided items
      for (const item of revisionData.items) {
        await this.createQuotationItem({
          quotationId: newQuotation.id,
          description: item.description,
          quantity: item.quantity,
          costPrice: item.costPrice,
          markup: item.markup,
          unitPrice: item.unitPrice,
          lineTotal: item.lineTotal,
          isAccepted: item.isAccepted ?? true,
          rejectionReason: item.rejectionReason,
          notes: item.notes,
        });
      }
    } else {
      // Copy original items
      for (const item of originalItems) {
        await this.createQuotationItem({
          quotationId: newQuotation.id,
          description: item.description,
          quantity: item.quantity,
          costPrice: item.costPrice,
          markup: item.markup,
          unitPrice: item.unitPrice,
          lineTotal: item.lineTotal,
          isAccepted: item.isAccepted,
          rejectionReason: item.rejectionReason,
          notes: item.notes,
        });
      }
    }

    // Log audit events
    await this.logAuditEvent("quotation", originalId, "supersede", userId, originalQuotation, { isSuperseded: true });
    await this.logAuditEvent("quotation", newQuotation.id, "create_revision", userId, undefined, newQuotation);

    return newQuotation;
  }

  async getQuotationRevisions(originalId: string): Promise<Quotation[]> {
    // Get the original quotation and find its root parent
    const quotation = await this.getQuotation(originalId);
    if (!quotation) {
      throw new Error("Quotation not found");
    }

    // Find the root parent (originalId could be a revision itself)
    const rootParentId = quotation.parentQuotationId || originalId;

    // Get all revisions including the original
    const allRevisions = await db.select()
      .from(quotations)
      .where(
        or(
          eq(quotations.id, rootParentId),
          eq(quotations.parentQuotationId, rootParentId)
        )
      )
      .orderBy(quotations.revision);

    return allRevisions;
  }

  async getQuotationHistory(quotationId: string): Promise<any[]> {
    // Get audit events for this quotation and its revisions
    const revisions = await this.getQuotationRevisions(quotationId);
    const allQuotationIds = revisions.map(q => q.id);

    const auditEvents = await db.select()
      .from(auditLog)
      .where(
        and(
          eq(auditLog.entityType, "quotation"),
          inArray(auditLog.entityId, allQuotationIds)
        )
      )
      .orderBy(desc(auditLog.timestamp));

    // Combine with approval events
    const approvalEvents = await db.select({
      id: quotationApprovals.id,
      quotationId: quotationApprovals.quotationId,
      action: sql<string>`'approval'`,
      status: quotationApprovals.status,
      comments: quotationApprovals.comments,
      timestamp: quotationApprovals.createdAt,
      userId: quotationApprovals.approverId,
    })
    .from(quotationApprovals)
    .where(inArray(quotationApprovals.quotationId, allQuotationIds))
    .orderBy(desc(quotationApprovals.createdAt));

    // Combine and sort all events
    const allEvents = [
      ...auditEvents.map(event => ({
        ...event,
        type: 'audit',
        action: event.action,
      })),
      ...approvalEvents.map(event => ({
        ...event,
        type: 'approval',
        action: event.status === 'Approved' ? 'approve' : event.status === 'Rejected' ? 'reject' : 'approval_request',
      }))
    ].sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

    return allEvents;
  }

  async generateQuotationFromEnquiry(enquiryId: string, userId: string): Promise<Quotation> {
    // Get enquiry details
    const enquiry = await this.getEnquiry(enquiryId);
    if (!enquiry) {
      throw new Error("Enquiry not found");
    }

    // Get customer details for pricing logic
    const customer = await this.getCustomer(enquiry.customerId);
    if (!customer) {
      throw new Error("Customer not found");
    }

    // Get enquiry items
    const enquiryItems = await this.getEnquiryItems(enquiryId);

    // Generate quote number
    const quoteCount = await db.select({ count: count() }).from(quotations);
    const quoteNumber = `QT-2024-${String(quoteCount[0].count + 1).padStart(3, '0')}`;

    // Calculate validity period (30 days from now)
    const validUntil = new Date();
    validUntil.setDate(validUntil.getDate() + 30);
    console.log("validUntil date object:", validUntil);
    console.log("validUntil type:", typeof validUntil);

    // Create quotation
    const quotationData: InsertQuotation = {
      quoteNumber,
      enquiryId,
      customerId: enquiry.customerId,
      customerType: customer.customerType,
      status: "Draft",
      validUntil,
      terms: "Payment due within 30 days of invoice date. Prices valid for 30 days.",
      notes: enquiry.notes || "",
      createdBy: userId,
    };

    console.log("quotationData:", quotationData);

    const [quotation] = await db.insert(quotations).values(quotationData).returning();

    // Process enquiry items and apply pricing logic
    let subtotal = 0;
    for (const item of enquiryItems) {
      if (item.unitPrice) {
        const costPrice = parseFloat(item.unitPrice.toString());
        const markup = customer.customerType === "Retail" ? 70 : 40; // RETAIL: 70%, WHOLESALE: 40%
        const unitPrice = costPrice * (1 + markup / 100);
        const lineTotal = unitPrice * item.quantity;

        await this.createQuotationItem({
          quotationId: quotation.id,
          description: item.description,
          quantity: item.quantity,
          costPrice: costPrice.toString(),
          markup: markup.toString(),
          unitPrice: unitPrice.toString(),
          lineTotal: lineTotal.toString(),
          isAccepted: true,
          notes: item.notes || "",
        });

        subtotal += lineTotal;
      }
    }

    // Calculate totals
    const taxAmount = subtotal * 0.05; // 5% tax
    const totalAmount = subtotal + taxAmount;

    // Determine if approval is needed
    const requiredApprovalLevel = await this.determineRequiredApprovalLevel({
      ...quotation,
      totalAmount: totalAmount.toString(),
      discountPercentage: "0",
      customerType: customer.customerType,
    });

    // Update quotation with calculated totals
    const updatedQuotation = await this.updateQuotation(quotation.id, {
      subtotal: subtotal.toString(),
      taxAmount: taxAmount.toString(),
      totalAmount: totalAmount.toString(),
      requiredApprovalLevel: requiredApprovalLevel as any,
      approvalStatus: requiredApprovalLevel ? "Pending" : "Approved",
    });

    // Update enquiry status
    await this.updateEnquiry(enquiryId, { status: "Quoted" });

    await this.logAuditEvent("quotation", quotation.id, "generate_from_enquiry", userId, undefined, updatedQuotation);
    return updatedQuotation;
  }

  async getQuotationItems(quotationId: string): Promise<QuotationItem[]> {
    try {
      console.log("Getting quotation items for quotation ID:", quotationId);
      // Temporary workaround: return empty array due to database schema mismatch
      // The database doesn't have the expected columns (description, barcode, supplier_code)
      console.log("Returning empty array due to database schema mismatch");
      return [];
      
      // Original code commented out:
      // const result = await db.select().from(quotationItems).where(eq(quotationItems.quotationId, quotationId));
      // console.log("Query result:", result);
      // return result;
    } catch (error) {
      console.error("Error in getQuotationItems:", error);
      return []; // Return empty array instead of throwing error
    }
  }

  async createQuotationItem(itemData: InsertQuotationItem): Promise<QuotationItem> {
    const [item] = await db.insert(quotationItems).values(itemData).returning();
    return item;
  }

  async updateQuotationItem(id: string, itemData: Partial<InsertQuotationItem>): Promise<QuotationItem> {
    const [item] = await db
      .update(quotationItems)
      .set(itemData)
      .where(eq(quotationItems.id, id))
      .returning();
    return item;
  }

  async deleteQuotationItem(id: string): Promise<void> {
    await db.delete(quotationItems).where(eq(quotationItems.id, id));
  }

  async getApprovalRules(): Promise<ApprovalRule[]> {
    return db.select().from(approvalRules).where(eq(approvalRules.isActive, true));
  }

  async createApprovalRule(ruleData: InsertApprovalRule): Promise<ApprovalRule> {
    const [rule] = await db.insert(approvalRules).values(ruleData).returning();
    return rule;
  }

  async updateApprovalRule(id: string, ruleData: Partial<InsertApprovalRule>): Promise<ApprovalRule> {
    const [rule] = await db
      .update(approvalRules)
      .set({ ...ruleData, updatedAt: new Date() })
      .where(eq(approvalRules.id, id))
      .returning();
    return rule;
  }

  async deleteApprovalRule(id: string): Promise<void> {
    await db.delete(approvalRules).where(eq(approvalRules.id, id));
  }

  async determineRequiredApprovalLevel(quotation: Partial<Quotation>): Promise<string | null> {
    const rules = await this.getApprovalRules();
    const totalAmount = parseFloat(quotation.totalAmount || "0");
    const discountPercentage = parseFloat(quotation.discountPercentage || "0");

    for (const rule of rules) {
      let matches = true;

      // Check customer type
      if (rule.customerType && quotation.customerType !== rule.customerType) {
        matches = false;
      }

      // Check quote value range
      if (rule.minQuoteValue && totalAmount < parseFloat(rule.minQuoteValue.toString())) {
        matches = false;
      }
      if (rule.maxQuoteValue && totalAmount > parseFloat(rule.maxQuoteValue.toString())) {
        matches = false;
      }

      // Check discount percentage
      if (rule.maxDiscountPercentage && discountPercentage > parseFloat(rule.maxDiscountPercentage.toString())) {
        matches = false;
      }

      if (matches) {
        return rule.requiredApprovalLevel;
      }
    }

    return null; // No approval required
  }

  async getQuotationApprovals(quotationId: string): Promise<QuotationApproval[]> {
    return db.select().from(quotationApprovals).where(eq(quotationApprovals.quotationId, quotationId));
  }

  async createQuotationApproval(approvalData: InsertQuotationApproval): Promise<QuotationApproval> {
    const [approval] = await db.insert(quotationApprovals).values(approvalData).returning();
    return approval;
  }

  // Customer Acceptance operations
  async getCustomerAcceptances(quotationId?: string): Promise<CustomerAcceptance[]> {
    let query = db.select().from(customerAcceptances);
    if (quotationId) {
      query = query.where(eq(customerAcceptances.quotationId, quotationId));
    }
    return query.orderBy(desc(customerAcceptances.createdAt));
  }

  async getCustomerAcceptance(id: string): Promise<CustomerAcceptance | undefined> {
    const [acceptance] = await db.select().from(customerAcceptances).where(eq(customerAcceptances.id, id));
    return acceptance;
  }

  async createCustomerAcceptance(acceptanceData: InsertCustomerAcceptance): Promise<CustomerAcceptance> {
    const [acceptance] = await db.insert(customerAcceptances).values(acceptanceData).returning();
    await this.logAuditEvent("customer_acceptance", acceptance.id, "create", undefined, undefined, acceptance);
    return acceptance;
  }

  async updateCustomerAcceptance(id: string, acceptanceData: Partial<InsertCustomerAcceptance>): Promise<CustomerAcceptance> {
    const oldAcceptance = await this.getCustomerAcceptance(id);
    const [acceptance] = await db
      .update(customerAcceptances)
      .set({ ...acceptanceData, updatedAt: new Date() })
      .where(eq(customerAcceptances.id, id))
      .returning();
    
    await this.logAuditEvent("customer_acceptance", id, "update", undefined, oldAcceptance, acceptance);
    return acceptance;
  }

  async deleteCustomerAcceptance(id: string): Promise<void> {
    const oldAcceptance = await this.getCustomerAcceptance(id);
    await db.delete(customerAcceptances).where(eq(customerAcceptances.id, id));
    await this.logAuditEvent("customer_acceptance", id, "delete", undefined, oldAcceptance, undefined);
  }

  // Purchase Order operations
  async getPurchaseOrders(quotationId?: string): Promise<PurchaseOrder[]> {
    let query = db.select().from(purchaseOrders);
    if (quotationId) {
      query = query.where(eq(purchaseOrders.quotationId, quotationId));
    }
    return query.orderBy(desc(purchaseOrders.createdAt));
  }

  async getPurchaseOrder(id: string): Promise<PurchaseOrder | undefined> {
    const [po] = await db.select().from(purchaseOrders).where(eq(purchaseOrders.id, id));
    return po;
  }

  async createPurchaseOrder(poData: InsertPurchaseOrder): Promise<PurchaseOrder> {
    const [po] = await db.insert(purchaseOrders).values(poData).returning();
    await this.logAuditEvent("purchase_order", po.id, "create", undefined, undefined, po);
    return po;
  }

  async updatePurchaseOrder(id: string, poData: Partial<InsertPurchaseOrder>): Promise<PurchaseOrder> {
    const oldPo = await this.getPurchaseOrder(id);
    const [po] = await db
      .update(purchaseOrders)
      .set({ ...poData, updatedAt: new Date() })
      .where(eq(purchaseOrders.id, id))
      .returning();
    
    await this.logAuditEvent("purchase_order", id, "update", undefined, oldPo, po);
    return po;
  }

  async deletePurchaseOrder(id: string): Promise<void> {
    const oldPo = await this.getPurchaseOrder(id);
    await db.delete(purchaseOrders).where(eq(purchaseOrders.id, id));
    await this.logAuditEvent("purchase_order", id, "delete", undefined, oldPo, undefined);
  }

  async validatePurchaseOrder(id: string, validationData: { status: string; notes?: string; validatedBy: string }): Promise<PurchaseOrder> {
    const [po] = await db
      .update(purchaseOrders)
      .set({
        validationStatus: validationData.status,
        validationNotes: validationData.notes,
        validatedBy: validationData.validatedBy,
        validatedAt: new Date(),
        updatedAt: new Date()
      })
      .where(eq(purchaseOrders.id, id))
      .returning();
    
    await this.logAuditEvent("purchase_order", id, "validate", validationData.validatedBy, undefined, po);
    return po;
  }

  // Quotation Item Acceptance operations
  async getQuotationItemAcceptances(customerAcceptanceId: string): Promise<QuotationItemAcceptance[]> {
    return db.select().from(quotationItemAcceptances).where(eq(quotationItemAcceptances.customerAcceptanceId, customerAcceptanceId));
  }

  async getQuotationItemAcceptance(id: string): Promise<QuotationItemAcceptance | undefined> {
    const [itemAcceptance] = await db.select().from(quotationItemAcceptances).where(eq(quotationItemAcceptances.id, id));
    return itemAcceptance;
  }

  async createQuotationItemAcceptance(itemAcceptanceData: InsertQuotationItemAcceptance): Promise<QuotationItemAcceptance> {
    const [itemAcceptance] = await db.insert(quotationItemAcceptances).values(itemAcceptanceData).returning();
    return itemAcceptance;
  }

  async updateQuotationItemAcceptance(id: string, itemAcceptanceData: Partial<InsertQuotationItemAcceptance>): Promise<QuotationItemAcceptance> {
    const [itemAcceptance] = await db
      .update(quotationItemAcceptances)
      .set({ ...itemAcceptanceData, updatedAt: new Date() })
      .where(eq(quotationItemAcceptances.id, id))
      .returning();
    
    return itemAcceptance;
  }

  async bulkCreateQuotationItemAcceptances(itemAcceptances: InsertQuotationItemAcceptance[]): Promise<QuotationItemAcceptance[]> {
    const results = await db.insert(quotationItemAcceptances).values(itemAcceptances).returning();
    return results;
  }

  // PO Line Items operations
  async getPoLineItems(purchaseOrderId: string): Promise<PoLineItem[]> {
    return db.select().from(poLineItems).where(eq(poLineItems.purchaseOrderId, purchaseOrderId));
  }

  async createPoLineItem(lineItemData: InsertPoLineItem): Promise<PoLineItem> {
    const [lineItem] = await db.insert(poLineItems).values(lineItemData).returning();
    return lineItem;
  }

  async updatePoLineItem(id: string, lineItemData: Partial<InsertPoLineItem>): Promise<PoLineItem> {
    const [lineItem] = await db
      .update(poLineItems)
      .set({ ...lineItemData, updatedAt: new Date() })
      .where(eq(poLineItems.id, id))
      .returning();
    
    return lineItem;
  }

  async bulkCreatePoLineItems(lineItems: InsertPoLineItem[]): Promise<PoLineItem[]> {
    const results = await db.insert(poLineItems).values(lineItems).returning();
    return results;
  }

  // Acceptance Confirmation operations
  async getAcceptanceConfirmations(customerAcceptanceId: string): Promise<AcceptanceConfirmation[]> {
    return db.select().from(acceptanceConfirmations).where(eq(acceptanceConfirmations.customerAcceptanceId, customerAcceptanceId));
  }

  async createAcceptanceConfirmation(confirmationData: InsertAcceptanceConfirmation): Promise<AcceptanceConfirmation> {
    const [confirmation] = await db.insert(acceptanceConfirmations).values(confirmationData).returning();
    return confirmation;
  }

  // Sales Order operations
  async getSalesOrders(limit = 50, offset = 0, filters?: {
    status?: string;
    customerId?: string;
    dateFrom?: string;
    dateTo?: string;
    search?: string;
  }): Promise<SalesOrder[]> {
    let query = db.select().from(salesOrders);
    
    const conditions = [];
    
    if (filters?.status) {
      conditions.push(eq(salesOrders.status, filters.status as any));
    }
    
    if (filters?.customerId) {
      conditions.push(eq(salesOrders.customerId, filters.customerId));
    }
    
    if (filters?.dateFrom) {
      conditions.push(sql`${salesOrders.orderDate} >= ${filters.dateFrom}`);
    }
    
    if (filters?.dateTo) {
      conditions.push(sql`${salesOrders.orderDate} <= ${filters.dateTo}`);
    }
    
    if (filters?.search) {
      conditions.push(
        or(
          like(salesOrders.orderNumber, `%${filters.search}%`),
          like(salesOrders.customerPoNumber, `%${filters.search}%`)
        )
      );
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    return query
      .limit(limit)
      .offset(offset)
      .orderBy(desc(salesOrders.createdAt));
  }

  async getSalesOrder(id: string): Promise<SalesOrder | undefined> {
    const [salesOrder] = await db.select().from(salesOrders).where(eq(salesOrders.id, id));
    return salesOrder;
  }

  async createSalesOrder(salesOrderData: InsertSalesOrder): Promise<SalesOrder> {
    // Generate order number
    const orderCount = await db.select({ count: count() }).from(salesOrders);
    const orderNumber = `SO-2025-${String(orderCount[0].count + 1).padStart(3, '0')}`;
    
    const [salesOrder] = await db
      .insert(salesOrders)
      .values({ ...salesOrderData, orderNumber })
      .returning();
    
    await this.logAuditEvent("sales_order", salesOrder.id, "create", salesOrderData.createdBy || undefined, undefined, salesOrder);
    return salesOrder;
  }

  async updateSalesOrder(id: string, salesOrderData: Partial<InsertSalesOrder>): Promise<SalesOrder> {
    const oldSalesOrder = await this.getSalesOrder(id);
    const [salesOrder] = await db
      .update(salesOrders)
      .set({ ...salesOrderData, updatedAt: new Date() })
      .where(eq(salesOrders.id, id))
      .returning();
    
    await this.logAuditEvent("sales_order", id, "update", undefined, oldSalesOrder, salesOrder);
    return salesOrder;
  }

  async deleteSalesOrder(id: string): Promise<void> {
    const salesOrder = await this.getSalesOrder(id);
    
    // First delete all sales order items
    await db.delete(salesOrderItems).where(eq(salesOrderItems.salesOrderId, id));
    
    // Then delete the sales order
    await db.delete(salesOrders).where(eq(salesOrders.id, id));
    
    await this.logAuditEvent("sales_order", id, "delete", undefined, salesOrder, undefined);
  }

  async createSalesOrderFromQuotation(quotationId: string, customerAcceptanceId?: string, userId?: string): Promise<SalesOrder> {
    // Get quotation and its items
    const quotation = await this.getQuotation(quotationId);
    if (!quotation) {
      throw new Error("Quotation not found");
    }

    // Temporarily bypass quotation items due to DB schema issues
    let quotationItems: any[] = [];
    try {
      quotationItems = await this.getQuotationItems(quotationId);
    } catch (error) {
      console.warn("Could not fetch quotation items due to DB schema mismatch, creating order without items:", error);
    }
    
    // If customer acceptance ID is provided, only include accepted items
    let itemsToInclude = quotationItems;
    if (customerAcceptanceId && quotationItems.length > 0) {
      try {
        const itemAcceptances = await this.getQuotationItemAcceptances(customerAcceptanceId);
        const acceptedItemIds = itemAcceptances
          .filter(acceptance => acceptance.isAccepted)
          .map(acceptance => acceptance.quotationItemId);
        
        itemsToInclude = quotationItems.filter(item => acceptedItemIds.includes(item.id));
      } catch (error) {
        console.warn("Could not fetch item acceptances, using all items:", error);
      }
    }

    // Generate order number
    const orderCount = await db.select({ count: count() }).from(salesOrders);
    const orderNumber = `SO-2025-${String(orderCount[0].count + 1).padStart(3, '0')}`;

    // Create sales order
    const salesOrderData: InsertSalesOrder = {
      orderNumber,
      quotationId,
      customerId: quotation.customerId,
      customerPoNumber: null,
      customerPoDocument: null,
      subtotal: quotation.subtotal,
      taxAmount: quotation.taxAmount,
      totalAmount: quotation.totalAmount,
      paymentTerms: quotation.terms,
      deliveryInstructions: null,
      sourceType: "Auto",
      customerLpoRequired: true,
      customerLpoValidationStatus: "Pending",
      isPartialOrder: customerAcceptanceId ? true : false,
      createdBy: userId || null,
    };

    const [salesOrder] = await db.insert(salesOrders).values(salesOrderData).returning();

    // Create sales order items with barcode enforcement (only if items are available)
    if (itemsToInclude.length > 0) {
      for (let i = 0; i < itemsToInclude.length; i++) {
        const quotationItem = itemsToInclude[i];
        
        try {
          // Get item details for barcode
          const item = await this.getItem(quotationItem.itemId);
          if (!item) {
            console.warn(`Item not found for quotation item ${quotationItem.id}, skipping`);
            continue;
          }

          // Barcode is mandatory - use item barcode or supplier code as fallback
          const barcode = item.barcode || item.supplierCode || `TEMP-${item.id.slice(0, 8)}`;

          const salesOrderItemData: InsertSalesOrderItem = {
            salesOrderId: salesOrder.id,
            itemId: quotationItem.itemId,
            lineNumber: i + 1,
            // supplierCode: item.supplierCode, // Temporarily commented out due to DB schema issue
            // barcode, // Temporarily commented out due to DB schema issue
            quantity: quotationItem.quantity,
            unitPrice: quotationItem.unitPrice,
            totalPrice: quotationItem.totalPrice,
            deliveryRequirement: null,
            specialInstructions: null,
          };

          await db.insert(salesOrderItems).values(salesOrderItemData);
        } catch (error) {
          console.warn(`Error creating sales order item for quotation item ${quotationItem.id}:`, error);
        }
      }
    } else {
      console.warn("No quotation items found, creating sales order without items");
    }

    await this.logAuditEvent("sales_order", salesOrder.id, "auto_create", userId, { quotationId, customerAcceptanceId }, salesOrder);
    return salesOrder;
  }

  async createAmendedSalesOrder(parentOrderId: string, reason: string, userId?: string): Promise<SalesOrder> {
    const parentOrder = await this.getSalesOrder(parentOrderId);
    if (!parentOrder) {
      throw new Error("Parent sales order not found");
    }

    const parentItems = await this.getSalesOrderItems(parentOrderId);

    // Generate order number for amendment
    const orderCount = await db.select({ count: count() }).from(salesOrders);
    const amendmentNumber = `${parentOrder.orderNumber}-AMD-${parentOrder.version + 1}`;

    // Create amended sales order
    const amendedOrderData: InsertSalesOrder = {
      ...parentOrder,
      orderNumber: amendmentNumber,
      version: parentOrder.version + 1,
      parentOrderId,
      amendmentReason: reason,
      status: "Draft",
      createdBy: userId || null,
    };

    delete (amendedOrderData as any).id;
    delete (amendedOrderData as any).createdAt;
    delete (amendedOrderData as any).updatedAt;

    const [amendedOrder] = await db.insert(salesOrders).values(amendedOrderData).returning();

    // Copy items from parent order
    for (const parentItem of parentItems) {
      const amendedItemData: InsertSalesOrderItem = {
        ...parentItem,
        salesOrderId: amendedOrder.id,
      };

      delete (amendedItemData as any).id;
      await db.insert(salesOrderItems).values(amendedItemData);
    }

    await this.logAuditEvent("sales_order", amendedOrder.id, "amend", userId, { parentOrderId, reason }, amendedOrder);
    return amendedOrder;
  }

  async validateCustomerLpo(id: string, validationData: { status: string; notes?: string; validatedBy: string }): Promise<SalesOrder> {
    const [salesOrder] = await db
      .update(salesOrders)
      .set({
        customerLpoValidationStatus: validationData.status,
        customerLpoValidatedBy: validationData.validatedBy,
        customerLpoValidatedAt: new Date(),
        updatedAt: new Date(),
      })
      .where(eq(salesOrders.id, id))
      .returning();

    await this.logAuditEvent("sales_order", id, "lpo_validate", validationData.validatedBy, undefined, { validationStatus: validationData.status, notes: validationData.notes });
    return salesOrder;
  }

  // Sales Order Item operations
  async getSalesOrderItems(salesOrderId: string): Promise<SalesOrderItem[]> {
    return db.select().from(salesOrderItems).where(eq(salesOrderItems.salesOrderId, salesOrderId));
  }

  async getSalesOrderItem(id: string): Promise<SalesOrderItem | undefined> {
    const [item] = await db.select().from(salesOrderItems).where(eq(salesOrderItems.id, id));
    return item;
  }

  async createSalesOrderItem(itemData: InsertSalesOrderItem): Promise<SalesOrderItem> {
    // Validate barcode is provided
    // if (!itemData.barcode) {
    //   throw new Error("Barcode is mandatory for sales order items");
    // } // Temporarily commented out due to DB schema issue

    const [item] = await db.insert(salesOrderItems).values(itemData).returning();
    await this.logAuditEvent("sales_order_item", item.id, "create", undefined, undefined, item);
    return item;
  }

  async updateSalesOrderItem(id: string, itemData: Partial<InsertSalesOrderItem>): Promise<SalesOrderItem> {
    const oldItem = await this.getSalesOrderItem(id);
    
    // Ensure barcode is still present after update
    // if (itemData.barcode === "" || itemData.barcode === null) {
    //   throw new Error("Barcode cannot be removed from sales order items");
    // } // Temporarily commented out due to DB schema issue

    const [item] = await db
      .update(salesOrderItems)
      .set(itemData)
      .where(eq(salesOrderItems.id, id))
      .returning();
    
    await this.logAuditEvent("sales_order_item", id, "update", undefined, oldItem, item);
    return item;
  }

  async deleteSalesOrderItem(id: string): Promise<void> {
    const item = await this.getSalesOrderItem(id);
    await db.delete(salesOrderItems).where(eq(salesOrderItems.id, id));
    
    await this.logAuditEvent("sales_order_item", id, "delete", undefined, item, undefined);
  }

  async bulkCreateSalesOrderItems(itemsData: InsertSalesOrderItem[]): Promise<SalesOrderItem[]> {
    // Validate all items have barcodes
    // for (const itemData of itemsData) {
    //   if (!itemData.barcode) {
    //     throw new Error("All sales order items must have barcodes");
    //   }
    // } // Temporarily commented out due to DB schema issue

    const items = await db.insert(salesOrderItems).values(itemsData).returning();
    
    // Log audit events for bulk creation
    for (const item of items) {
      await this.logAuditEvent("sales_order_item", item.id, "bulk_create", undefined, undefined, item);
    }
    
    return items;
  }

  // Supplier LPO operations implementation
  async getSupplierLpos(limit = 50, offset = 0, filters: {
    status?: string;
    supplierId?: string;
    dateFrom?: string;
    dateTo?: string;
    search?: string;
  } = {}): Promise<SupplierLpo[]> {
    let query = db
      .select({
        id: supplierLpos.id,
        lpoNumber: supplierLpos.lpoNumber,
        supplierId: supplierLpos.supplierId,
        status: supplierLpos.status,
        lpoDate: supplierLpos.lpoDate,
        // Only using basic columns that should exist in any version
        createdAt: supplierLpos.createdAt,
        updatedAt: supplierLpos.updatedAt,
        supplierName: suppliers.name,
      })
      .from(supplierLpos)
      .leftJoin(suppliers, eq(supplierLpos.supplierId, suppliers.id));

    const conditions = [];

    if (filters.status) {
      conditions.push(eq(supplierLpos.status, filters.status as any));
    }

    if (filters.supplierId) {
      conditions.push(eq(supplierLpos.supplierId, filters.supplierId));
    }

    if (filters.dateFrom) {
      conditions.push(sql`${supplierLpos.lpoDate} >= ${filters.dateFrom}`);
    }

    if (filters.dateTo) {
      conditions.push(sql`${supplierLpos.lpoDate} <= ${filters.dateTo}`);
    }

    if (filters.search) {
      conditions.push(
        or(
          like(supplierLpos.lpoNumber, `%${filters.search}%`),
          like(suppliers.name, `%${filters.search}%`),
          like(supplierLpos.supplierContactPerson, `%${filters.search}%`)
        )
      );
    }

    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }

    return query
      .limit(limit)
      .offset(offset)
      .orderBy(desc(supplierLpos.createdAt));
  }

  async getSupplierLpo(id: string): Promise<SupplierLpo | undefined> {
    const [lpo] = await db
      .select()
      .from(supplierLpos)
      .where(eq(supplierLpos.id, id));
    return lpo;
  }

  async createSupplierLpo(lpoData: InsertSupplierLpo): Promise<SupplierLpo> {
    // Generate LPO number if not provided
    if (!lpoData.lpoNumber) {
      const today = new Date();
      const year = today.getFullYear();
      const month = String(today.getMonth() + 1).padStart(2, '0');
      const count = await db.select({ count: sql`count(*)` }).from(supplierLpos);
      const sequence = String((count[0]?.count as number || 0) + 1).padStart(4, '0');
      lpoData.lpoNumber = `LPO-${year}${month}-${sequence}`;
    }

    const [lpo] = await db.insert(supplierLpos).values(lpoData).returning();
    await this.logAuditEvent("supplier_lpo", lpo.id, "create", lpoData.createdBy, undefined, lpo);
    return lpo;
  }

  async updateSupplierLpo(id: string, lpoData: Partial<InsertSupplierLpo>): Promise<SupplierLpo> {
    const oldLpo = await this.getSupplierLpo(id);
    const [lpo] = await db
      .update(supplierLpos)
      .set({ ...lpoData, updatedAt: new Date() })
      .where(eq(supplierLpos.id, id))
      .returning();
    
    await this.logAuditEvent("supplier_lpo", id, "update", undefined, oldLpo, lpo);
    return lpo;
  }

  async deleteSupplierLpo(id: string): Promise<void> {
    const oldLpo = await this.getSupplierLpo(id);
    await db.delete(supplierLpos).where(eq(supplierLpos.id, id));
    await this.logAuditEvent("supplier_lpo", id, "delete", undefined, oldLpo, undefined);
  }

  async createSupplierLposFromSalesOrders(salesOrderIds: string[], groupBy: string, userId?: string): Promise<SupplierLpo[]> {
    // Get sales order items with quotation information grouped by supplier
    const salesOrderItems = await db
      .select({
        salesOrderId: salesOrderItems.salesOrderId,
        itemId: salesOrderItems.itemId,
        lineNumber: salesOrderItems.lineNumber,
        // supplierCode: salesOrderItems.supplierCode, // Temporarily commented out due to DB schema issue
        barcode: salesOrderItems.barcode,
        quantity: salesOrderItems.quantity,
        unitPrice: salesOrderItems.unitPrice,
        totalPrice: salesOrderItems.totalPrice,
        deliveryRequirement: salesOrderItems.deliveryRequirement,
        specialInstructions: salesOrderItems.specialInstructions,
        supplierId: items.supplierId,
        supplierName: suppliers.name,
        supplierEmail: suppliers.email,
        supplierPhone: suppliers.phone,
        supplierContactPerson: suppliers.contactPerson,
        supplierPaymentTerms: suppliers.paymentTerms,
        itemDescription: items.description,
        itemSupplierCode: items.supplierCode,
        itemCostPrice: items.costPrice,
        // Quotation information for traceability
        quotationId: salesOrders.quotationId,
        quotationNumber: quotations.quoteNumber,
      })
      .from(salesOrderItems)
      .leftJoin(items, eq(salesOrderItems.itemId, items.id))
      .leftJoin(suppliers, eq(items.supplierId, suppliers.id))
      .leftJoin(salesOrders, eq(salesOrderItems.salesOrderId, salesOrders.id))
      .leftJoin(quotations, eq(salesOrders.quotationId, quotations.id))
      .where(sql`${salesOrderItems.salesOrderId} = ANY(${salesOrderIds})`);

    // Group items by supplier
    const supplierGroups = salesOrderItems.reduce((groups, item) => {
      const key = item.supplierId;
      if (!key) return groups;
      
      if (!groups[key]) {
        groups[key] = {
          supplier: {
            id: item.supplierId,
            name: item.supplierName,
            email: item.supplierEmail,
            phone: item.supplierPhone,
            contactPerson: item.supplierContactPerson,
            paymentTerms: item.supplierPaymentTerms,
          },
          items: [],
          quotationIds: new Set()
        };
      }
      groups[key].items.push(item);
      if (item.quotationId) {
        groups[key].quotationIds.add(item.quotationId);
      }
      return groups;
    }, {} as any);

    const createdLpos: SupplierLpo[] = [];

    // Create LPO for each supplier
    for (const [supplierId, group] of Object.entries(supplierGroups) as any) {
      const subtotal = group.items.reduce((sum: number, item: any) => 
        sum + (Number(item.itemCostPrice || 0) * item.quantity), 0);
      const taxAmount = subtotal * 0.1; // 10% tax
      const totalAmount = subtotal + taxAmount;

      const lpoData: InsertSupplierLpo = {
        supplierId: group.supplier.id,
        status: "Draft",
        sourceType: "Auto",
        sourceSalesOrderIds: salesOrderIds,
        sourceQuotationIds: Array.from(group.quotationIds), // Add quotation traceability
        groupingCriteria: groupBy,
        subtotal: subtotal.toString(),
        taxAmount: taxAmount.toString(),
        totalAmount: totalAmount.toString(),
        currency: "USD",
        supplierContactPerson: group.supplier.contactPerson,
        supplierEmail: group.supplier.email,
        supplierPhone: group.supplier.phone,
        paymentTerms: group.supplier.paymentTerms,
        deliveryTerms: "FOB Destination",
        termsAndConditions: "Standard terms and conditions apply",
        createdBy: userId,
      };

      const lpo = await this.createSupplierLpo(lpoData);

      // Create LPO items
      const lpoItems = group.items.map((item: any) => ({
        supplierLpoId: lpo.id,
        salesOrderItemId: item.salesOrderId,
        itemId: item.itemId,
        lineNumber: item.lineNumber,
        supplierCode: item.itemSupplierCode || "TEMP-CODE", // Use item supplier code as fallback
        barcode: item.barcode,
        itemDescription: item.itemDescription,
        quantity: item.quantity,
        unitCost: item.itemCostPrice || "0",
        totalCost: (Number(item.itemCostPrice || 0) * item.quantity).toString(),
        // requestedDeliveryDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days from now - Temporarily disabled until schema sync
        urgency: "Normal",
        specialInstructions: item.specialInstructions,
      }));

      await this.bulkCreateSupplierLpoItems(lpoItems);
      createdLpos.push(lpo);
    }

    return createdLpos;
  }

  async createAmendedSupplierLpo(parentLpoId: string, reason: string, amendmentType: string, userId?: string): Promise<SupplierLpo> {
    const parentLpo = await this.getSupplierLpo(parentLpoId);
    if (!parentLpo) {
      throw new Error("Parent LPO not found");
    }

    const parentItems = await this.getSupplierLpoItems(parentLpoId);

    // Create amended LPO
    const amendedLpoData: InsertSupplierLpo = {
      ...parentLpo,
      id: undefined as any,
      lpoNumber: undefined as any, // Will be auto-generated
      version: (parentLpo.version || 1) + 1,
      parentLpoId: parentLpoId,
      amendmentReason: reason,
      amendmentType: amendmentType,
      status: "Draft",
      requiresApproval: true,
      approvalStatus: "Pending",
      sentToSupplierAt: null,
      confirmedBySupplierAt: null,
      supplierConfirmationReference: null,
      createdBy: userId,
    };

    const amendedLpo = await this.createSupplierLpo(amendedLpoData);

    // Copy items to amended LPO
    const amendedItems = parentItems.map(item => ({
      ...item,
      id: undefined as any,
      supplierLpoId: amendedLpo.id,
    }));

    await this.bulkCreateSupplierLpoItems(amendedItems);

    return amendedLpo;
  }

  async submitForApproval(id: string, userId: string): Promise<SupplierLpo> {
    return this.updateSupplierLpo(id, {
      requiresApproval: true,
      approvalStatus: "Pending",
    });
  }

  async approveSupplierLpo(id: string, userId: string, notes?: string): Promise<SupplierLpo> {
    return this.updateSupplierLpo(id, {
      approvalStatus: "Approved",
      approvedBy: userId,
      approvedAt: new Date(),
      approvalNotes: notes,
    });
  }

  async rejectSupplierLpo(id: string, userId: string, notes: string): Promise<SupplierLpo> {
    return this.updateSupplierLpo(id, {
      approvalStatus: "Rejected",
      approvedBy: userId,
      approvedAt: new Date(),
      approvalNotes: notes,
    });
  }

  async sendToSupplier(id: string, userId: string): Promise<SupplierLpo> {
    return this.updateSupplierLpo(id, {
      status: "Sent",
      sentToSupplierAt: new Date(),
    });
  }

  async confirmBySupplier(id: string, confirmationReference?: string): Promise<SupplierLpo> {
    return this.updateSupplierLpo(id, {
      status: "Confirmed",
      confirmedBySupplierAt: new Date(),
      supplierConfirmationReference: confirmationReference,
    });
  }

  async getSupplierLpoBacklog(): Promise<any[]> {
    return db
      .select({
        lpoId: supplierLpos.id,
        lpoNumber: supplierLpos.lpoNumber,
        supplierName: suppliers.name,
        status: supplierLpos.status,
        lpoDate: supplierLpos.lpoDate,
        expectedDeliveryDate: supplierLpos.expectedDeliveryDate,
        totalAmount: supplierLpos.totalAmount,
        daysPending: sql`EXTRACT(DAY FROM (NOW() - ${supplierLpos.lpoDate}))`,
        itemCount: sql`COUNT(${supplierLpoItems.id})`,
        pendingItems: sql`SUM(${supplierLpoItems.pendingQuantity})`,
      })
      .from(supplierLpos)
      .leftJoin(suppliers, eq(supplierLpos.supplierId, suppliers.id))
      .leftJoin(supplierLpoItems, eq(supplierLpos.id, supplierLpoItems.supplierLpoId))
      .where(
        or(
          eq(supplierLpos.status, "Sent"),
          eq(supplierLpos.status, "Confirmed")
        )
      )
      .groupBy(
        supplierLpos.id,
        supplierLpos.lpoNumber,
        suppliers.name,
        supplierLpos.status,
        supplierLpos.lpoDate,
        supplierLpos.expectedDeliveryDate,
        supplierLpos.totalAmount
      )
      .orderBy(desc(supplierLpos.lpoDate));
  }

  async getCustomerOrderBacklog(): Promise<any[]> {
    return db
      .select({
        orderId: salesOrders.id,
        orderNumber: salesOrders.orderNumber,
        customerName: customers.name,
        status: salesOrders.status,
        orderDate: salesOrders.orderDate,
        totalAmount: salesOrders.totalAmount,
        daysPending: sql`EXTRACT(DAY FROM (NOW() - ${salesOrders.orderDate}))`,
        itemCount: sql`COUNT(${salesOrderItems.id})`,
      })
      .from(salesOrders)
      .leftJoin(customers, eq(salesOrders.customerId, customers.id))
      .leftJoin(salesOrderItems, eq(salesOrders.id, salesOrderItems.salesOrderId))
      .where(
        or(
          eq(salesOrders.status, "Confirmed"),
          eq(salesOrders.status, "Processing")
        )
      )
      .groupBy(
        salesOrders.id,
        salesOrders.orderNumber,
        customers.name,
        salesOrders.status,
        salesOrders.orderDate,
        salesOrders.totalAmount
      )
      .orderBy(desc(salesOrders.orderDate));
  }

  // Supplier LPO Item operations
  async getSupplierLpoItems(supplierLpoId: string): Promise<SupplierLpoItem[]> {
    return db
      .select()
      .from(supplierLpoItems)
      .where(eq(supplierLpoItems.supplierLpoId, supplierLpoId))
      .orderBy(supplierLpoItems.lineNumber);
  }

  async getSupplierLpoItem(id: string): Promise<SupplierLpoItem | undefined> {
    const [item] = await db
      .select()
      .from(supplierLpoItems)
      .where(eq(supplierLpoItems.id, id));
    return item;
  }

  async createSupplierLpoItem(itemData: InsertSupplierLpoItem): Promise<SupplierLpoItem> {
    const [item] = await db.insert(supplierLpoItems).values(itemData).returning();
    await this.logAuditEvent("supplier_lpo_item", item.id, "create", undefined, undefined, item);
    return item;
  }

  async updateSupplierLpoItem(id: string, itemData: Partial<InsertSupplierLpoItem>): Promise<SupplierLpoItem> {
    const oldItem = await this.getSupplierLpoItem(id);
    const [item] = await db
      .update(supplierLpoItems)
      .set({ ...itemData, updatedAt: new Date() })
      .where(eq(supplierLpoItems.id, id))
      .returning();
    
    await this.logAuditEvent("supplier_lpo_item", id, "update", undefined, oldItem, item);
    return item;
  }

  async deleteSupplierLpoItem(id: string): Promise<void> {
    const oldItem = await this.getSupplierLpoItem(id);
    await db.delete(supplierLpoItems).where(eq(supplierLpoItems.id, id));
    await this.logAuditEvent("supplier_lpo_item", id, "delete", undefined, oldItem, undefined);
  }

  async bulkCreateSupplierLpoItems(items: InsertSupplierLpoItem[]): Promise<SupplierLpoItem[]> {
    if (items.length === 0) return [];
    
    const createdItems = await db.insert(supplierLpoItems).values(items).returning();
    
    for (const item of createdItems) {
      await this.logAuditEvent("supplier_lpo_item", item.id, "create", undefined, undefined, item);
    }
    
    return createdItems;
  }

  async getDashboardStats(): Promise<{
    activeEnquiries: number;
    pendingQuotes: number;
    activeOrders: number;
    monthlyRevenue: number;
  }> {
    const [activeEnquiriesResult] = await db
      .select({ count: count() })
      .from(enquiries)
      .where(or(eq(enquiries.status, "New"), eq(enquiries.status, "In Progress")));

    const [pendingQuotesResult] = await db
      .select({ count: count() })
      .from(quotations)
      .where(or(eq(quotations.status, "Draft"), eq(quotations.status, "Sent")));

    const [activeOrdersResult] = await db
      .select({ count: count() })
      .from(salesOrders)
      .where(
        and(
          or(
            eq(salesOrders.status, "Confirmed"),
            eq(salesOrders.status, "Processing"),
            eq(salesOrders.status, "Shipped")
          )
        )
      );

    // Calculate monthly revenue (this is a simplified calculation)
    const [revenueResult] = await db
      .select({ 
        sum: count() // This would be a sum of totalAmount in real implementation
      })
      .from(invoices)
      .where(eq(invoices.status, "Paid"));

    return {
      activeEnquiries: activeEnquiriesResult.count,
      pendingQuotes: pendingQuotesResult.count,
      activeOrders: activeOrdersResult.count,
      monthlyRevenue: revenueResult.sum * 12000, // Mock calculation
    };
  }

  // Inventory Item operations
  async getInventoryItems(filters?: {
    search?: string;
    supplierId?: string;
    category?: string;
    isActive?: boolean;
    limit?: number;
    offset?: number;
  }): Promise<InventoryItem[]> {
    let query = db.select().from(inventoryItems);
    
    const conditions = [];
    if (filters?.search) {
      conditions.push(
        or(
          like(inventoryItems.supplierCode, `%${filters.search}%`),
          like(inventoryItems.description, `%${filters.search}%`),
          like(inventoryItems.barcode, `%${filters.search}%`)
        )
      );
    }
    if (filters?.supplierId) {
      conditions.push(eq(inventoryItems.supplierId, filters.supplierId));
    }
    if (filters?.category) {
      conditions.push(eq(inventoryItems.category, filters.category));
    }
    if (filters?.isActive !== undefined) {
      conditions.push(eq(inventoryItems.isActive, filters.isActive));
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    if (filters?.limit) {
      query = query.limit(filters.limit);
    }
    if (filters?.offset) {
      query = query.offset(filters.offset);
    }
    
    return query.orderBy(inventoryItems.description);
  }

  async getInventoryItem(id: string): Promise<InventoryItem | undefined> {
    const [item] = await db
      .select()
      .from(inventoryItems)
      .where(eq(inventoryItems.id, id));
    return item;
  }

  async getInventoryItemBySupplierCode(supplierCode: string): Promise<InventoryItem | undefined> {
    const [item] = await db
      .select()
      .from(inventoryItems)
      .where(eq(inventoryItems.supplierCode, supplierCode));
    return item;
  }

  async getInventoryItemByBarcode(barcode: string): Promise<InventoryItem | undefined> {
    const [item] = await db
      .select()
      .from(inventoryItems)
      .where(eq(inventoryItems.barcode, barcode));
    return item;
  }

  async createInventoryItem(itemData: InsertInventoryItem): Promise<InventoryItem> {
    const [item] = await db.insert(inventoryItems).values(itemData).returning();
    await this.logAuditEvent("inventory_item", item.id, "create", undefined, undefined, item);
    return item;
  }

  async updateInventoryItem(id: string, itemData: Partial<InsertInventoryItem>): Promise<InventoryItem> {
    const oldItem = await this.getInventoryItem(id);
    const [item] = await db
      .update(inventoryItems)
      .set({ ...itemData, updatedAt: new Date() })
      .where(eq(inventoryItems.id, id))
      .returning();
    
    await this.logAuditEvent("inventory_item", id, "update", undefined, oldItem, item);
    return item;
  }

  async deleteInventoryItem(id: string): Promise<void> {
    const oldItem = await this.getInventoryItem(id);
    await db.delete(inventoryItems).where(eq(inventoryItems.id, id));
    await this.logAuditEvent("inventory_item", id, "delete", undefined, oldItem, undefined);
  }

  async bulkCreateInventoryItems(items: InsertInventoryItem[]): Promise<InventoryItem[]> {
    if (items.length === 0) return [];
    
    const createdItems = await db.insert(inventoryItems).values(items).returning();
    
    for (const item of createdItems) {
      await this.logAuditEvent("inventory_item", item.id, "create", undefined, undefined, item);
    }
    
    return createdItems;
  }

  // Inventory Variant operations
  async getInventoryVariants(itemId: string): Promise<InventoryVariant[]> {
    return db
      .select()
      .from(inventoryVariants)
      .where(eq(inventoryVariants.inventoryItemId, itemId))
      .orderBy(inventoryVariants.variantName);
  }

  async getInventoryVariant(id: string): Promise<InventoryVariant | undefined> {
    const [variant] = await db
      .select()
      .from(inventoryVariants)
      .where(eq(inventoryVariants.id, id));
    return variant;
  }

  async createInventoryVariant(variantData: InsertInventoryVariant): Promise<InventoryVariant> {
    const [variant] = await db.insert(inventoryVariants).values(variantData).returning();
    await this.logAuditEvent("inventory_variant", variant.id, "create", undefined, undefined, variant);
    return variant;
  }

  async updateInventoryVariant(id: string, variantData: Partial<InsertInventoryVariant>): Promise<InventoryVariant> {
    const oldVariant = await this.getInventoryVariant(id);
    const [variant] = await db
      .update(inventoryVariants)
      .set({ ...variantData, updatedAt: new Date() })
      .where(eq(inventoryVariants.id, id))
      .returning();
    
    await this.logAuditEvent("inventory_variant", id, "update", undefined, oldVariant, variant);
    return variant;
  }

  async deleteInventoryVariant(id: string): Promise<void> {
    const oldVariant = await this.getInventoryVariant(id);
    await db.delete(inventoryVariants).where(eq(inventoryVariants.id, id));
    await this.logAuditEvent("inventory_variant", id, "delete", undefined, oldVariant, undefined);
  }

  // Inventory Level operations (stock levels)
  async getInventoryLevels(filters?: {
    itemId?: string;
    location?: string;
    lowStock?: boolean;
  }): Promise<Inventory[]> {
    let query = db.select().from(inventoryLevels);
    
    const conditions = [];
    if (filters?.itemId) {
      conditions.push(eq(inventoryLevels.inventoryItemId, filters.itemId));
    }
    if (filters?.location) {
      conditions.push(eq(inventoryLevels.storageLocation, filters.location));
    }
    if (filters?.lowStock) {
      // Assuming low stock is when available quantity is less than reorder level
      conditions.push(sql`${inventoryLevels.quantityAvailable} < ${inventoryLevels.reorderLevel}`);
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    return query.orderBy(inventoryLevels.storageLocation, inventoryLevels.inventoryItemId);
  }

  async getInventoryLevel(id: string): Promise<Inventory | undefined> {
    const [level] = await db
      .select()
      .from(inventoryLevels)
      .where(eq(inventoryLevels.id, id));
    return level;
  }

  async getInventoryLevelByItem(itemId: string, location?: string): Promise<Inventory | undefined> {
    let query = db
      .select()
      .from(inventoryLevels)
      .where(eq(inventoryLevels.inventoryItemId, itemId));
    
    if (location) {
      query = query.where(and(eq(inventoryLevels.inventoryItemId, itemId), eq(inventoryLevels.storageLocation, location)));
    }
    
    const [level] = await query;
    return level;
  }

  async createInventoryLevel(inventoryData: InsertInventory): Promise<Inventory> {
    const [level] = await db.insert(inventoryLevels).values(inventoryData).returning();
    await this.logAuditEvent("inventory_level", level.id, "create", undefined, undefined, level);
    return level;
  }

  async updateInventoryLevel(id: string, inventoryData: Partial<InsertInventory>): Promise<Inventory> {
    const oldLevel = await this.getInventoryLevel(id);
    const [level] = await db
      .update(inventoryLevels)
      .set({ ...inventoryData, lastUpdated: new Date() })
      .where(eq(inventoryLevels.id, id))
      .returning();
    
    await this.logAuditEvent("inventory_level", id, "update", undefined, oldLevel, level);
    return level;
  }

  async deleteInventoryLevel(id: string): Promise<void> {
    const oldLevel = await this.getInventoryLevel(id);
    await db.delete(inventoryLevels).where(eq(inventoryLevels.id, id));
    await this.logAuditEvent("inventory_level", id, "delete", undefined, oldLevel, undefined);
  }

  async adjustInventoryQuantity(itemId: string, quantityChange: number, location?: string, reason?: string): Promise<Inventory> {
    // Get current inventory level
    const currentLevel = await this.getInventoryLevelByItem(itemId, location);
    
    if (!currentLevel) {
      throw new Error(`Inventory level not found for item ${itemId} at location ${location || 'default'}`);
    }
    
    const newQuantity = currentLevel.quantityOnHand + quantityChange;
    const newAvailable = Math.max(0, newQuantity - currentLevel.quantityReserved);
    
    // Update inventory level
    const updatedLevel = await this.updateInventoryLevel(currentLevel.id, {
      quantityOnHand: newQuantity,
      quantityAvailable: newAvailable,
    });
    
    // Create stock movement record
    await this.createStockMovement({
      itemId,
      movementType: quantityChange > 0 ? "Receipt" : "Issue",
      referenceType: "Adjustment",
      storageLocation: location || "Default",
      quantityBefore: currentLevel.quantityOnHand,
      quantityMoved: Math.abs(quantityChange),
      quantityAfter: newQuantity,
      notes: reason,
    });
    
    return updatedLevel;
  }

  // Goods Receipt Header operations
  async getGoodsReceiptHeaders(filters?: {
    status?: string;
    supplierLpoId?: string;
    dateFrom?: string;
    dateTo?: string;
    limit?: number;
    offset?: number;
  }): Promise<GoodsReceiptHeader[]> {
    let query = db.select().from(goodsReceiptHeaders);
    
    const conditions = [];
    if (filters?.status) {
      conditions.push(eq(goodsReceiptHeaders.status, filters.status));
    }
    if (filters?.supplierLpoId) {
      conditions.push(eq(goodsReceiptHeaders.supplierLpoId, filters.supplierLpoId));
    }
    if (filters?.dateFrom) {
      conditions.push(sql`${goodsReceiptHeaders.receiptDate} >= ${filters.dateFrom}`);
    }
    if (filters?.dateTo) {
      conditions.push(sql`${goodsReceiptHeaders.receiptDate} <= ${filters.dateTo}`);
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    if (filters?.limit) {
      query = query.limit(filters.limit);
    }
    if (filters?.offset) {
      query = query.offset(filters.offset);
    }
    
    return query.orderBy(desc(goodsReceiptHeaders.receiptDate));
  }

  async getGoodsReceiptHeader(id: string): Promise<GoodsReceiptHeader | undefined> {
    const [receipt] = await db
      .select()
      .from(goodsReceiptHeaders)
      .where(eq(goodsReceiptHeaders.id, id));
    return receipt;
  }

  async getGoodsReceiptByNumber(receiptNumber: string): Promise<GoodsReceiptHeader | undefined> {
    const [receipt] = await db
      .select()
      .from(goodsReceiptHeaders)
      .where(eq(goodsReceiptHeaders.receiptNumber, receiptNumber));
    return receipt;
  }

  async createGoodsReceiptHeader(receiptData: InsertGoodsReceiptHeader): Promise<GoodsReceiptHeader> {
    const [receipt] = await db.insert(goodsReceiptHeaders).values(receiptData).returning();
    await this.logAuditEvent("goods_receipt_header", receipt.id, "create", undefined, undefined, receipt);
    return receipt;
  }

  async updateGoodsReceiptHeader(id: string, receiptData: Partial<InsertGoodsReceiptHeader>): Promise<GoodsReceiptHeader> {
    const oldReceipt = await this.getGoodsReceiptHeader(id);
    const [receipt] = await db
      .update(goodsReceiptHeaders)
      .set({ ...receiptData, updatedAt: new Date() })
      .where(eq(goodsReceiptHeaders.id, id))
      .returning();
    
    await this.logAuditEvent("goods_receipt_header", id, "update", undefined, oldReceipt, receipt);
    return receipt;
  }

  async deleteGoodsReceiptHeader(id: string): Promise<void> {
    const oldReceipt = await this.getGoodsReceiptHeader(id);
    await db.delete(goodsReceiptHeaders).where(eq(goodsReceiptHeaders.id, id));
    await this.logAuditEvent("goods_receipt_header", id, "delete", undefined, oldReceipt, undefined);
  }

  // Goods Receipt Item operations
  async getGoodsReceiptItems(goodsReceiptId: string): Promise<GoodsReceiptItem[]> {
    return db
      .select()
      .from(goodsReceiptItems)
      .where(eq(goodsReceiptItems.goodsReceiptId, goodsReceiptId))
      .orderBy(goodsReceiptItems.lineNumber);
  }

  async getGoodsReceiptItem(id: string): Promise<GoodsReceiptItem | undefined> {
    const [item] = await db
      .select()
      .from(goodsReceiptItems)
      .where(eq(goodsReceiptItems.id, id));
    return item;
  }

  async createGoodsReceiptItem(itemData: InsertGoodsReceiptItem): Promise<GoodsReceiptItem> {
    const [item] = await db.insert(goodsReceiptItems).values(itemData).returning();
    await this.logAuditEvent("goods_receipt_item", item.id, "create", undefined, undefined, item);
    return item;
  }

  async updateGoodsReceiptItem(id: string, itemData: Partial<InsertGoodsReceiptItem>): Promise<GoodsReceiptItem> {
    const oldItem = await this.getGoodsReceiptItem(id);
    const [item] = await db
      .update(goodsReceiptItems)
      .set({ ...itemData, updatedAt: new Date() })
      .where(eq(goodsReceiptItems.id, id))
      .returning();
    
    await this.logAuditEvent("goods_receipt_item", id, "update", undefined, oldItem, item);
    return item;
  }

  async deleteGoodsReceiptItem(id: string): Promise<void> {
    const oldItem = await this.getGoodsReceiptItem(id);
    await db.delete(goodsReceiptItems).where(eq(goodsReceiptItems.id, id));
    await this.logAuditEvent("goods_receipt_item", id, "delete", undefined, oldItem, undefined);
  }

  async bulkCreateGoodsReceiptItems(items: InsertGoodsReceiptItem[]): Promise<GoodsReceiptItem[]> {
    if (items.length === 0) return [];
    
    const createdItems = await db.insert(goodsReceiptItems).values(items).returning();
    
    for (const item of createdItems) {
      await this.logAuditEvent("goods_receipt_item", item.id, "create", undefined, undefined, item);
    }
    
    return createdItems;
  }

  // Scanning Session operations
  async getScanningSessions(filters?: {
    status?: string;
    goodsReceiptId?: string;
    dateFrom?: string;
    dateTo?: string;
  }): Promise<ScanningSession[]> {
    let query = db.select().from(scanningSessions);
    
    const conditions = [];
    if (filters?.status) {
      conditions.push(eq(scanningSessions.status, filters.status));
    }
    if (filters?.goodsReceiptId) {
      conditions.push(eq(scanningSessions.goodsReceiptId, filters.goodsReceiptId));
    }
    if (filters?.dateFrom) {
      conditions.push(sql`${scanningSessions.startedAt} >= ${filters.dateFrom}`);
    }
    if (filters?.dateTo) {
      conditions.push(sql`${scanningSessions.startedAt} <= ${filters.dateTo}`);
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    return query.orderBy(desc(scanningSessions.startedAt));
  }

  async getScanningSession(id: string): Promise<ScanningSession | undefined> {
    const [session] = await db
      .select()
      .from(scanningSessions)
      .where(eq(scanningSessions.id, id));
    return session;
  }

  async createScanningSession(sessionData: InsertScanningSession): Promise<ScanningSession> {
    const [session] = await db.insert(scanningSessions).values(sessionData).returning();
    await this.logAuditEvent("scanning_session", session.id, "create", undefined, undefined, session);
    return session;
  }

  async updateScanningSession(id: string, sessionData: Partial<InsertScanningSession>): Promise<ScanningSession> {
    const oldSession = await this.getScanningSession(id);
    const [session] = await db
      .update(scanningSessions)
      .set({ ...sessionData, updatedAt: new Date() })
      .where(eq(scanningSessions.id, id))
      .returning();
    
    await this.logAuditEvent("scanning_session", id, "update", undefined, oldSession, session);
    return session;
  }

  async deleteScanningSession(id: string): Promise<void> {
    const oldSession = await this.getScanningSession(id);
    await db.delete(scanningSessions).where(eq(scanningSessions.id, id));
    await this.logAuditEvent("scanning_session", id, "delete", undefined, oldSession, undefined);
  }

  // Scanned Item operations
  async getScannedItems(scanningSessionId: string): Promise<ScannedItem[]> {
    return db
      .select()
      .from(scannedItems)
      .where(eq(scannedItems.scanningSessionId, scanningSessionId))
      .orderBy(scannedItems.scannedAt);
  }

  async getScannedItem(id: string): Promise<ScannedItem | undefined> {
    const [item] = await db
      .select()
      .from(scannedItems)
      .where(eq(scannedItems.id, id));
    return item;
  }

  async createScannedItem(itemData: InsertScannedItem): Promise<ScannedItem> {
    const [item] = await db.insert(scannedItems).values(itemData).returning();
    await this.logAuditEvent("scanned_item", item.id, "create", undefined, undefined, item);
    return item;
  }

  async updateScannedItem(id: string, itemData: Partial<InsertScannedItem>): Promise<ScannedItem> {
    const oldItem = await this.getScannedItem(id);
    const [item] = await db
      .update(scannedItems)
      .set(itemData)
      .where(eq(scannedItems.id, id))
      .returning();
    
    await this.logAuditEvent("scanned_item", id, "update", undefined, oldItem, item);
    return item;
  }

  async deleteScannedItem(id: string): Promise<void> {
    const oldItem = await this.getScannedItem(id);
    await db.delete(scannedItems).where(eq(scannedItems.id, id));
    await this.logAuditEvent("scanned_item", id, "delete", undefined, oldItem, undefined);
  }

  async bulkCreateScannedItems(items: InsertScannedItem[]): Promise<ScannedItem[]> {
    if (items.length === 0) return [];
    
    const createdItems = await db.insert(scannedItems).values(items).returning();
    
    for (const item of createdItems) {
      await this.logAuditEvent("scanned_item", item.id, "create", undefined, undefined, item);
    }
    
    return createdItems;
  }

  // Supplier Return operations
  async getSupplierReturns(filters?: {
    status?: string;
    supplierId?: string;
    dateFrom?: string;
    dateTo?: string;
    limit?: number;
    offset?: number;
  }): Promise<SupplierReturn[]> {
    let query = db.select().from(supplierReturns);
    
    const conditions = [];
    if (filters?.status) {
      conditions.push(eq(supplierReturns.status, filters.status));
    }
    if (filters?.supplierId) {
      conditions.push(eq(supplierReturns.supplierId, filters.supplierId));
    }
    if (filters?.dateFrom) {
      conditions.push(sql`${supplierReturns.returnDate} >= ${filters.dateFrom}`);
    }
    if (filters?.dateTo) {
      conditions.push(sql`${supplierReturns.returnDate} <= ${filters.dateTo}`);
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    if (filters?.limit) {
      query = query.limit(filters.limit);
    }
    if (filters?.offset) {
      query = query.offset(filters.offset);
    }
    
    return query.orderBy(desc(supplierReturns.returnDate));
  }

  async getSupplierReturn(id: string): Promise<SupplierReturn | undefined> {
    const [supplierReturn] = await db
      .select()
      .from(supplierReturns)
      .where(eq(supplierReturns.id, id));
    return supplierReturn;
  }

  async getSupplierReturnByNumber(returnNumber: string): Promise<SupplierReturn | undefined> {
    const [supplierReturn] = await db
      .select()
      .from(supplierReturns)
      .where(eq(supplierReturns.returnNumber, returnNumber));
    return supplierReturn;
  }

  async createSupplierReturn(returnData: InsertSupplierReturn): Promise<SupplierReturn> {
    const [supplierReturn] = await db.insert(supplierReturns).values(returnData).returning();
    await this.logAuditEvent("supplier_return", supplierReturn.id, "create", undefined, undefined, supplierReturn);
    return supplierReturn;
  }

  async updateSupplierReturn(id: string, returnData: Partial<InsertSupplierReturn>): Promise<SupplierReturn> {
    const oldReturn = await this.getSupplierReturn(id);
    const [supplierReturn] = await db
      .update(supplierReturns)
      .set({ ...returnData, updatedAt: new Date() })
      .where(eq(supplierReturns.id, id))
      .returning();
    
    await this.logAuditEvent("supplier_return", id, "update", undefined, oldReturn, supplierReturn);
    return supplierReturn;
  }

  async deleteSupplierReturn(id: string): Promise<void> {
    const oldReturn = await this.getSupplierReturn(id);
    await db.delete(supplierReturns).where(eq(supplierReturns.id, id));
    await this.logAuditEvent("supplier_return", id, "delete", undefined, oldReturn, undefined);
  }

  // Supplier Return Item operations
  async getSupplierReturnItems(supplierReturnId: string): Promise<SupplierReturnItem[]> {
    return db
      .select()
      .from(supplierReturnItems)
      .where(eq(supplierReturnItems.supplierReturnId, supplierReturnId))
      .orderBy(supplierReturnItems.lineNumber);
  }

  async getSupplierReturnItem(id: string): Promise<SupplierReturnItem | undefined> {
    const [item] = await db
      .select()
      .from(supplierReturnItems)
      .where(eq(supplierReturnItems.id, id));
    return item;
  }

  async createSupplierReturnItem(itemData: InsertSupplierReturnItem): Promise<SupplierReturnItem> {
    const [item] = await db.insert(supplierReturnItems).values(itemData).returning();
    await this.logAuditEvent("supplier_return_item", item.id, "create", undefined, undefined, item);
    return item;
  }

  async updateSupplierReturnItem(id: string, itemData: Partial<InsertSupplierReturnItem>): Promise<SupplierReturnItem> {
    const oldItem = await this.getSupplierReturnItem(id);
    const [item] = await db
      .update(supplierReturnItems)
      .set({ ...itemData, updatedAt: new Date() })
      .where(eq(supplierReturnItems.id, id))
      .returning();
    
    await this.logAuditEvent("supplier_return_item", id, "update", undefined, oldItem, item);
    return item;
  }

  async deleteSupplierReturnItem(id: string): Promise<void> {
    const oldItem = await this.getSupplierReturnItem(id);
    await db.delete(supplierReturnItems).where(eq(supplierReturnItems.id, id));
    await this.logAuditEvent("supplier_return_item", id, "delete", undefined, oldItem, undefined);
  }

  async bulkCreateSupplierReturnItems(items: InsertSupplierReturnItem[]): Promise<SupplierReturnItem[]> {
    if (items.length === 0) return [];
    
    const createdItems = await db.insert(supplierReturnItems).values(items).returning();
    
    for (const item of createdItems) {
      await this.logAuditEvent("supplier_return_item", item.id, "create", undefined, undefined, item);
    }
    
    return createdItems;
  }

  // Stock Movement operations
  async getStockMovements(filters?: {
    itemId?: string;
    movementType?: string;
    referenceType?: string;
    referenceId?: string;
    dateFrom?: string;
    dateTo?: string;
    limit?: number;
    offset?: number;
  }): Promise<StockMovement[]> {
    let query = db.select().from(stockMovements);
    
    const conditions = [];
    if (filters?.itemId) {
      conditions.push(eq(stockMovements.itemId, filters.itemId));
    }
    if (filters?.movementType) {
      conditions.push(eq(stockMovements.movementType, filters.movementType));
    }
    if (filters?.referenceType) {
      conditions.push(eq(stockMovements.referenceType, filters.referenceType));
    }
    if (filters?.referenceId) {
      conditions.push(eq(stockMovements.referenceId, filters.referenceId));
    }
    if (filters?.dateFrom) {
      conditions.push(sql`${stockMovements.createdAt} >= ${filters.dateFrom}`);
    }
    if (filters?.dateTo) {
      conditions.push(sql`${stockMovements.createdAt} <= ${filters.dateTo}`);
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    if (filters?.limit) {
      query = query.limit(filters.limit);
    }
    if (filters?.offset) {
      query = query.offset(filters.offset);
    }
    
    return query.orderBy(desc(stockMovements.createdAt));
  }

  async getStockMovement(id: string): Promise<StockMovement | undefined> {
    const [movement] = await db
      .select()
      .from(stockMovements)
      .where(eq(stockMovements.id, id));
    return movement;
  }

  async createStockMovement(movementData: InsertStockMovement): Promise<StockMovement> {
    const [movement] = await db.insert(stockMovements).values(movementData).returning();
    await this.logAuditEvent("stock_movement", movement.id, "create", undefined, undefined, movement);
    return movement;
  }

  async getItemStockHistory(itemId: string, limit?: number): Promise<StockMovement[]> {
    let query = db
      .select()
      .from(stockMovements)
      .where(eq(stockMovements.itemId, itemId))
      .orderBy(desc(stockMovements.createdAt));
    
    if (limit) {
      query = query.limit(limit);
    }
    
    return query;
  }

  // DELIVERY OPERATIONS - Comprehensive delivery management with barcode picking
  async getDeliveries(filters?: {
    status?: string;
    salesOrderId?: string;
    dateFrom?: string;
    dateTo?: string;
    limit?: number;
    offset?: number;
  }): Promise<Delivery[]> {
    let query = db.select({
      id: deliveries.id,
      deliveryNumber: deliveries.deliveryNumber,
      salesOrderId: deliveries.salesOrderId,
      deliveryDate: deliveries.deliveryDate,
      status: deliveries.status,
      deliveryAddress: deliveries.deliveryAddress,
      deliveryNotes: deliveries.deliveryNotes,
      // Only basic columns until schema is fully synchronized
      createdAt: deliveries.createdAt,
      updatedAt: deliveries.updatedAt,
    }).from(deliveries);
    
    const conditions = [];
    if (filters?.status) {
      conditions.push(eq(deliveries.status, filters.status));
    }
    if (filters?.salesOrderId) {
      conditions.push(eq(deliveries.salesOrderId, filters.salesOrderId));
    }
    if (filters?.dateFrom) {
      conditions.push(sql`${deliveries.deliveryDate} >= ${filters.dateFrom}`);
    }
    if (filters?.dateTo) {
      conditions.push(sql`${deliveries.deliveryDate} <= ${filters.dateTo}`);
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    if (filters?.limit) query = query.limit(filters.limit);
    if (filters?.offset) query = query.offset(filters.offset);
    
    return query.orderBy(desc(deliveries.deliveryDate));
  }

  async getDelivery(id: string): Promise<Delivery | undefined> {
    const [delivery] = await db.select().from(deliveries).where(eq(deliveries.id, id));
    return delivery;
  }

  async getDeliveryByNumber(deliveryNumber: string): Promise<Delivery | undefined> {
    const [delivery] = await db.select().from(deliveries).where(eq(deliveries.deliveryNumber, deliveryNumber));
    return delivery;
  }

  async createDelivery(deliveryData: InsertDelivery): Promise<Delivery> {
    const [delivery] = await db.insert(deliveries).values(deliveryData).returning();
    await this.logAuditEvent("delivery", delivery.id, "create", undefined, undefined, delivery);
    return delivery;
  }

  async updateDelivery(id: string, deliveryData: Partial<InsertDelivery>): Promise<Delivery> {
    const oldDelivery = await this.getDelivery(id);
    const [delivery] = await db
      .update(deliveries)
      .set({ ...deliveryData, updatedAt: new Date() })
      .where(eq(deliveries.id, id))
      .returning();
    
    await this.logAuditEvent("delivery", id, "update", undefined, oldDelivery, delivery);
    return delivery;
  }

  async deleteDelivery(id: string): Promise<void> {
    const oldDelivery = await this.getDelivery(id);
    await db.delete(deliveries).where(eq(deliveries.id, id));
    await this.logAuditEvent("delivery", id, "delete", undefined, oldDelivery, undefined);
  }

  async startDeliveryPicking(deliveryId: string, userId: string): Promise<Delivery> {
    return this.updateDelivery(deliveryId, {
      pickingStartedBy: userId,
      pickingStartedAt: new Date(),
      status: "Partial"
    });
  }

  async completeDeliveryPicking(deliveryId: string, userId: string, notes?: string): Promise<Delivery> {
    return this.updateDelivery(deliveryId, {
      pickingCompletedBy: userId,
      pickingCompletedAt: new Date(),
      pickingNotes: notes,
      status: "Complete"
    });
  }

  async confirmDelivery(deliveryId: string, confirmedBy: string, signature?: string): Promise<Delivery> {
    return this.updateDelivery(deliveryId, {
      deliveryConfirmedBy: confirmedBy,
      deliveryConfirmedAt: new Date(),
      deliverySignature: signature,
      actualDeliveryDate: new Date(),
      status: "Complete"
    });
  }

  // DELIVERY ITEM OPERATIONS - Enhanced with barcode tracking
  async getDeliveryItems(deliveryId: string): Promise<DeliveryItem[]> {
    return db.select().from(deliveryItems).where(eq(deliveryItems.deliveryId, deliveryId));
  }

  async getDeliveryItem(id: string): Promise<DeliveryItem | undefined> {
    const [item] = await db.select().from(deliveryItems).where(eq(deliveryItems.id, id));
    return item;
  }

  async createDeliveryItem(itemData: InsertDeliveryItem): Promise<DeliveryItem> {
    const [item] = await db.insert(deliveryItems).values(itemData).returning();
    await this.logAuditEvent("delivery_item", item.id, "create", undefined, undefined, item);
    return item;
  }

  async updateDeliveryItem(id: string, itemData: Partial<InsertDeliveryItem>): Promise<DeliveryItem> {
    const oldItem = await this.getDeliveryItem(id);
    const [item] = await db
      .update(deliveryItems)
      .set(itemData)
      .where(eq(deliveryItems.id, id))
      .returning();
    
    await this.logAuditEvent("delivery_item", id, "update", undefined, oldItem, item);
    return item;
  }

  async deleteDeliveryItem(id: string): Promise<void> {
    const oldItem = await this.getDeliveryItem(id);
    await db.delete(deliveryItems).where(eq(deliveryItems.id, id));
    await this.logAuditEvent("delivery_item", id, "delete", undefined, oldItem, undefined);
  }

  async bulkCreateDeliveryItems(items: InsertDeliveryItem[]): Promise<DeliveryItem[]> {
    if (items.length === 0) return [];
    const createdItems = await db.insert(deliveryItems).values(items).returning();
    
    for (const item of createdItems) {
      await this.logAuditEvent("delivery_item", item.id, "create", undefined, undefined, item);
    }
    
    return createdItems;
  }

  // INVOICE OPERATIONS - Comprehensive multi-currency invoice management
  async getInvoices(filters?: {
    status?: string;
    type?: string;
    customerId?: string;
    salesOrderId?: string;
    dateFrom?: string;
    dateTo?: string;
    currency?: string;
    limit?: number;
    offset?: number;
  }): Promise<Invoice[]> {
    let query = db.select().from(invoices);
    
    const conditions = [];
    if (filters?.status) {
      conditions.push(eq(invoices.status, filters.status));
    }
    if (filters?.type) {
      conditions.push(eq(invoices.invoiceType, filters.type));
    }
    if (filters?.customerId) {
      conditions.push(eq(invoices.customerId, filters.customerId));
    }
    if (filters?.salesOrderId) {
      conditions.push(eq(invoices.salesOrderId, filters.salesOrderId));
    }
    if (filters?.currency) {
      conditions.push(eq(invoices.currency, filters.currency));
    }
    if (filters?.dateFrom) {
      conditions.push(sql`${invoices.invoiceDate} >= ${filters.dateFrom}`);
    }
    if (filters?.dateTo) {
      conditions.push(sql`${invoices.invoiceDate} <= ${filters.dateTo}`);
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    if (filters?.limit) query = query.limit(filters.limit);
    if (filters?.offset) query = query.offset(filters.offset);
    
    return query.orderBy(desc(invoices.invoiceDate));
  }

  async getInvoice(id: string): Promise<Invoice | undefined> {
    const [invoice] = await db.select().from(invoices).where(eq(invoices.id, id));
    return invoice;
  }

  async getInvoiceByNumber(invoiceNumber: string): Promise<Invoice | undefined> {
    const [invoice] = await db.select().from(invoices).where(eq(invoices.invoiceNumber, invoiceNumber));
    return invoice;
  }

  async createInvoice(invoiceData: InsertInvoice): Promise<Invoice> {
    const [invoice] = await db.insert(invoices).values(invoiceData).returning();
    await this.logAuditEvent("invoice", invoice.id, "create", undefined, undefined, invoice);
    return invoice;
  }

  async updateInvoice(id: string, invoiceData: Partial<InsertInvoice>): Promise<Invoice> {
    const oldInvoice = await this.getInvoice(id);
    const [invoice] = await db
      .update(invoices)
      .set({ ...invoiceData, updatedAt: new Date() })
      .where(eq(invoices.id, id))
      .returning();
    
    await this.logAuditEvent("invoice", id, "update", undefined, oldInvoice, invoice);
    return invoice;
  }

  async deleteInvoice(id: string): Promise<void> {
    const oldInvoice = await this.getInvoice(id);
    await db.delete(invoices).where(eq(invoices.id, id));
    await this.logAuditEvent("invoice", id, "delete", undefined, oldInvoice, undefined);
  }

  async generateInvoiceFromDelivery(deliveryId: string, invoiceType: string = "Final", userId?: string): Promise<Invoice> {
    const delivery = await this.getDelivery(deliveryId);
    if (!delivery) throw new Error("Delivery not found");

    const salesOrder = await this.getSalesOrder(delivery.salesOrderId);
    if (!salesOrder) throw new Error("Sales order not found");

    // Generate invoice number
    const invoiceNumber = `INV-${Date.now()}`;

    const invoiceData: InsertInvoice = {
      invoiceNumber,
      invoiceType,
      salesOrderId: delivery.salesOrderId,
      deliveryId,
      customerId: salesOrder.customerId,
      dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days from now
      currency: salesOrder.currency || "USD",
      exchangeRate: salesOrder.exchangeRate || "1.0000",
      subtotal: salesOrder.subtotal,
      taxAmount: salesOrder.taxAmount,
      totalAmount: salesOrder.totalAmount,
      outstandingAmount: salesOrder.totalAmount,
      autoGenerated: true,
      generatedFromDeliveryId: deliveryId,
      createdBy: userId
    };

    return this.createInvoice(invoiceData);
  }

  async generateProformaInvoice(salesOrderId: string, userId?: string): Promise<Invoice> {
    const salesOrder = await this.getSalesOrder(salesOrderId);
    if (!salesOrder) throw new Error("Sales order not found");

    const invoiceNumber = `PI-${Date.now()}`;

    const invoiceData: InsertInvoice = {
      invoiceNumber,
      invoiceType: "Proforma",
      salesOrderId,
      customerId: salesOrder.customerId,
      currency: salesOrder.currency || "USD",
      exchangeRate: salesOrder.exchangeRate || "1.0000",
      subtotal: salesOrder.subtotal,
      taxAmount: salesOrder.taxAmount,
      totalAmount: salesOrder.totalAmount,
      outstandingAmount: salesOrder.totalAmount,
      autoGenerated: true,
      createdBy: userId
    };

    return this.createInvoice(invoiceData);
  }

  async sendInvoice(invoiceId: string, userId: string): Promise<Invoice> {
    return this.updateInvoice(invoiceId, {
      status: "Sent"
    });
  }

  async markInvoicePaid(invoiceId: string, paidAmount: number, paymentMethod?: string, paymentReference?: string, userId?: string): Promise<Invoice> {
    const invoice = await this.getInvoice(invoiceId);
    if (!invoice) throw new Error("Invoice not found");

    const newPaidAmount = Number(invoice.paidAmount || 0) + paidAmount;
    const outstandingAmount = Number(invoice.totalAmount || 0) - newPaidAmount;
    const status = outstandingAmount <= 0 ? "Paid" : "Partial";

    return this.updateInvoice(invoiceId, {
      paidAmount: newPaidAmount.toString(),
      outstandingAmount: outstandingAmount.toString(),
      status,
      paymentMethod,
      paymentReference,
      lastPaymentDate: new Date()
    });
  }

  // BARCODE SCANNING AND VERIFICATION
  async verifyItemBarcode(barcode: string, expectedItemId?: string): Promise<{ valid: boolean; item?: any; message: string }> {
    const item = await this.getInventoryItemByBarcode(barcode);
    
    if (!item) {
      return { valid: false, message: "Item not found for this barcode" };
    }

    if (expectedItemId && item.id !== expectedItemId) {
      return { valid: false, item, message: "Barcode does not match expected item" };
    }

    return { valid: true, item, message: "Barcode verified successfully" };
  }

  async scanItemForPicking(barcode: string, sessionId: string, quantity: number, userId: string, storageLocation?: string): Promise<DeliveryPickedItem> {
    const verification = await this.verifyItemBarcode(barcode);
    if (!verification.valid) {
      throw new Error(verification.message);
    }

    // Find the delivery item that matches this barcode
    const session = await this.getDeliveryPickingSession(sessionId);
    if (!session) throw new Error("Picking session not found");

    const deliveryItems = await this.getDeliveryItems(session.deliveryId);
    const matchingDeliveryItem = deliveryItems.find(item => item.barcode === barcode);
    
    if (!matchingDeliveryItem) {
      throw new Error("This item is not part of this delivery");
    }

    const pickedItemData: InsertDeliveryPickedItem = {
      pickingSessionId: sessionId,
      deliveryItemId: matchingDeliveryItem.id,
      barcode,
      quantityPicked: quantity,
      storageLocation,
      pickedBy: userId,
      verified: true,
      verifiedBy: userId,
      verifiedAt: new Date()
    };

    return this.createDeliveryPickedItem(pickedItemData);
  }

  async getAvailableItemsForPicking(deliveryId: string): Promise<any[]> {
    const deliveryItems = await this.getDeliveryItems(deliveryId);
    
    // Add inventory level information for each item
    const itemsWithInventory = await Promise.all(
      deliveryItems.map(async (deliveryItem) => {
        const inventoryLevels = await this.getInventoryLevels({
          itemId: deliveryItem.itemId,
          limit: 1
        });
        
        return {
          ...deliveryItem,
          availableQuantity: inventoryLevels[0]?.quantityAvailable || 0,
          storageLocation: inventoryLevels[0]?.storageLocation || "Unknown"
        };
      })
    );

    return itemsWithInventory;
  }

  // DELIVERY PICKING SESSION OPERATIONS
  async getDeliveryPickingSessions(deliveryId: string): Promise<DeliveryPickingSession[]> {
    return db.select().from(deliveryPickingSessions).where(eq(deliveryPickingSessions.deliveryId, deliveryId));
  }

  async getDeliveryPickingSession(id: string): Promise<DeliveryPickingSession | undefined> {
    const [session] = await db.select().from(deliveryPickingSessions).where(eq(deliveryPickingSessions.id, id));
    return session;
  }

  async createDeliveryPickingSession(sessionData: InsertDeliveryPickingSession): Promise<DeliveryPickingSession> {
    const [session] = await db.insert(deliveryPickingSessions).values(sessionData).returning();
    await this.logAuditEvent("delivery_picking_session", session.id, "create", undefined, undefined, session);
    return session;
  }

  async updateDeliveryPickingSession(id: string, sessionData: Partial<InsertDeliveryPickingSession>): Promise<DeliveryPickingSession> {
    const oldSession = await this.getDeliveryPickingSession(id);
    const [session] = await db
      .update(deliveryPickingSessions)
      .set(sessionData)
      .where(eq(deliveryPickingSessions.id, id))
      .returning();
    
    await this.logAuditEvent("delivery_picking_session", id, "update", undefined, oldSession, session);
    return session;
  }

  async completePickingSession(sessionId: string): Promise<DeliveryPickingSession> {
    return this.updateDeliveryPickingSession(sessionId, {
      completedAt: new Date(),
      status: "Completed"
    });
  }

  // DELIVERY PICKED ITEM OPERATIONS
  async getDeliveryPickedItems(sessionId: string): Promise<DeliveryPickedItem[]> {
    return db.select().from(deliveryPickedItems).where(eq(deliveryPickedItems.pickingSessionId, sessionId));
  }

  async getDeliveryPickedItem(id: string): Promise<DeliveryPickedItem | undefined> {
    const [item] = await db.select().from(deliveryPickedItems).where(eq(deliveryPickedItems.id, id));
    return item;
  }

  async createDeliveryPickedItem(itemData: InsertDeliveryPickedItem): Promise<DeliveryPickedItem> {
    const [item] = await db.insert(deliveryPickedItems).values(itemData).returning();
    await this.logAuditEvent("delivery_picked_item", item.id, "create", undefined, undefined, item);
    return item;
  }

  async updateDeliveryPickedItem(id: string, itemData: Partial<InsertDeliveryPickedItem>): Promise<DeliveryPickedItem> {
    const oldItem = await this.getDeliveryPickedItem(id);
    const [item] = await db
      .update(deliveryPickedItems)
      .set(itemData)
      .where(eq(deliveryPickedItems.id, id))
      .returning();
    
    await this.logAuditEvent("delivery_picked_item", id, "update", undefined, oldItem, item);
    return item;
  }

  async verifyPickedItem(itemId: string, userId: string): Promise<DeliveryPickedItem> {
    return this.updateDeliveryPickedItem(itemId, {
      verified: true,
      verifiedBy: userId,
      verifiedAt: new Date()
    });
  }

  // INVOICE ITEM OPERATIONS
  async getInvoiceItems(invoiceId: string): Promise<InvoiceItem[]> {
    return db.select().from(invoiceItems).where(eq(invoiceItems.invoiceId, invoiceId));
  }

  async getInvoiceItem(id: string): Promise<InvoiceItem | undefined> {
    const [item] = await db.select().from(invoiceItems).where(eq(invoiceItems.id, id));
    return item;
  }

  async createInvoiceItem(itemData: InsertInvoiceItem): Promise<InvoiceItem> {
    const [item] = await db.insert(invoiceItems).values(itemData).returning();
    await this.logAuditEvent("invoice_item", item.id, "create", undefined, undefined, item);
    return item;
  }

  async updateInvoiceItem(id: string, itemData: Partial<InsertInvoiceItem>): Promise<InvoiceItem> {
    const oldItem = await this.getInvoiceItem(id);
    const [item] = await db
      .update(invoiceItems)
      .set(itemData)
      .where(eq(invoiceItems.id, id))
      .returning();
    
    await this.logAuditEvent("invoice_item", id, "update", undefined, oldItem, item);
    return item;
  }

  async deleteInvoiceItem(id: string): Promise<void> {
    const oldItem = await this.getInvoiceItem(id);
    await db.delete(invoiceItems).where(eq(invoiceItems.id, id));
    await this.logAuditEvent("invoice_item", id, "delete", undefined, oldItem, undefined);
  }

  async bulkCreateInvoiceItems(items: InsertInvoiceItem[]): Promise<InvoiceItem[]> {
    if (items.length === 0) return [];
    const createdItems = await db.insert(invoiceItems).values(items).returning();
    
    for (const item of createdItems) {
      await this.logAuditEvent("invoice_item", item.id, "create", undefined, undefined, item);
    }
    
    return createdItems;
  }

  // CREDIT NOTE OPERATIONS - Returns and adjustments
  async getCreditNotes(filters?: {
    status?: string;
    customerId?: string;
    originalInvoiceId?: string;
    dateFrom?: string;
    dateTo?: string;
    limit?: number;
    offset?: number;
  }): Promise<CreditNote[]> {
    let query = db.select().from(creditNotes);
    
    const conditions = [];
    if (filters?.status) {
      conditions.push(eq(creditNotes.status, filters.status));
    }
    if (filters?.customerId) {
      conditions.push(eq(creditNotes.customerId, filters.customerId));
    }
    if (filters?.originalInvoiceId) {
      conditions.push(eq(creditNotes.originalInvoiceId, filters.originalInvoiceId));
    }
    if (filters?.dateFrom) {
      conditions.push(sql`${creditNotes.creditNoteDate} >= ${filters.dateFrom}`);
    }
    if (filters?.dateTo) {
      conditions.push(sql`${creditNotes.creditNoteDate} <= ${filters.dateTo}`);
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    if (filters?.limit) query = query.limit(filters.limit);
    if (filters?.offset) query = query.offset(filters.offset);
    
    return query.orderBy(desc(creditNotes.creditNoteDate));
  }

  async getCreditNote(id: string): Promise<CreditNote | undefined> {
    const [creditNote] = await db.select().from(creditNotes).where(eq(creditNotes.id, id));
    return creditNote;
  }

  async getCreditNoteByNumber(creditNoteNumber: string): Promise<CreditNote | undefined> {
    const [creditNote] = await db.select().from(creditNotes).where(eq(creditNotes.creditNoteNumber, creditNoteNumber));
    return creditNote;
  }

  async createCreditNote(creditNoteData: InsertCreditNote): Promise<CreditNote> {
    const [creditNote] = await db.insert(creditNotes).values(creditNoteData).returning();
    await this.logAuditEvent("credit_note", creditNote.id, "create", undefined, undefined, creditNote);
    return creditNote;
  }

  async updateCreditNote(id: string, creditNoteData: Partial<InsertCreditNote>): Promise<CreditNote> {
    const oldCreditNote = await this.getCreditNote(id);
    const [creditNote] = await db
      .update(creditNotes)
      .set({ ...creditNoteData, updatedAt: new Date() })
      .where(eq(creditNotes.id, id))
      .returning();
    
    await this.logAuditEvent("credit_note", id, "update", undefined, oldCreditNote, creditNote);
    return creditNote;
  }

  async deleteCreditNote(id: string): Promise<void> {
    const oldCreditNote = await this.getCreditNote(id);
    await db.delete(creditNotes).where(eq(creditNotes.id, id));
    await this.logAuditEvent("credit_note", id, "delete", undefined, oldCreditNote, undefined);
  }

  async generateCreditNoteFromReturn(invoiceId: string, returnItems: any[], reason: string, userId?: string): Promise<CreditNote> {
    const invoice = await this.getInvoice(invoiceId);
    if (!invoice) throw new Error("Invoice not found");

    const creditNoteNumber = `CN-${Date.now()}`;
    
    // Calculate credit note totals
    const subtotal = returnItems.reduce((sum, item) => sum + (item.quantity * item.unitPrice), 0);
    const taxAmount = subtotal * (Number(invoice.taxRate || 0) / 100);
    const totalAmount = subtotal + taxAmount;

    const creditNoteData: InsertCreditNote = {
      creditNoteNumber,
      originalInvoiceId: invoiceId,
      customerId: invoice.customerId,
      reason,
      currency: invoice.currency,
      exchangeRate: invoice.exchangeRate,
      subtotal: subtotal.toString(),
      taxAmount: taxAmount.toString(),
      totalAmount: totalAmount.toString(),
      createdBy: userId
    };

    return this.createCreditNote(creditNoteData);
  }

  async applyCreditNote(creditNoteId: string, appliedAmount: number, userId: string): Promise<CreditNote> {
    const creditNote = await this.getCreditNote(creditNoteId);
    if (!creditNote) throw new Error("Credit note not found");

    const newAppliedAmount = Number(creditNote.appliedAmount || 0) + appliedAmount;
    const status = newAppliedAmount >= Number(creditNote.totalAmount || 0) ? "Applied" : "Partial";

    return this.updateCreditNote(creditNoteId, {
      appliedAmount: newAppliedAmount.toString(),
      status
    });
  }

  // CREDIT NOTE ITEM OPERATIONS
  async getCreditNoteItems(creditNoteId: string): Promise<CreditNoteItem[]> {
    return db.select().from(creditNoteItems).where(eq(creditNoteItems.creditNoteId, creditNoteId));
  }

  async getCreditNoteItem(id: string): Promise<CreditNoteItem | undefined> {
    const [item] = await db.select().from(creditNoteItems).where(eq(creditNoteItems.id, id));
    return item;
  }

  async createCreditNoteItem(itemData: InsertCreditNoteItem): Promise<CreditNoteItem> {
    const [item] = await db.insert(creditNoteItems).values(itemData).returning();
    await this.logAuditEvent("credit_note_item", item.id, "create", undefined, undefined, item);
    return item;
  }

  async updateCreditNoteItem(id: string, itemData: Partial<InsertCreditNoteItem>): Promise<CreditNoteItem> {
    const oldItem = await this.getCreditNoteItem(id);
    const [item] = await db
      .update(creditNoteItems)
      .set(itemData)
      .where(eq(creditNoteItems.id, id))
      .returning();
    
    await this.logAuditEvent("credit_note_item", id, "update", undefined, oldItem, item);
    return item;
  }

  async deleteCreditNoteItem(id: string): Promise<void> {
    const oldItem = await this.getCreditNoteItem(id);
    await db.delete(creditNoteItems).where(eq(creditNoteItems.id, id));
    await this.logAuditEvent("credit_note_item", id, "delete", undefined, oldItem, undefined);
  }

  async bulkCreateCreditNoteItems(items: InsertCreditNoteItem[]): Promise<CreditNoteItem[]> {
    if (items.length === 0) return [];
    const createdItems = await db.insert(creditNoteItems).values(items).returning();
    
    for (const item of createdItems) {
      await this.logAuditEvent("credit_note_item", item.id, "create", undefined, undefined, item);
    }
    
    return createdItems;
  }

  // MULTI-CURRENCY OPERATIONS
  async convertCurrency(amount: number, fromCurrency: string, toCurrency: string, exchangeRate?: number): Promise<number> {
    if (fromCurrency === toCurrency) return amount;
    
    const rate = exchangeRate || await this.getExchangeRate(fromCurrency, toCurrency);
    return amount * rate;
  }

  async getExchangeRate(fromCurrency: string, toCurrency: string): Promise<number> {
    // In a real implementation, this would fetch from an external API
    // For now, return 1.0 as default exchange rate
    return 1.0;
  }

  async updateInvoiceCurrency(invoiceId: string, newCurrency: string, exchangeRate: number, userId: string): Promise<Invoice> {
    const invoice = await this.getInvoice(invoiceId);
    if (!invoice) throw new Error("Invoice not found");

    const convertedSubtotal = await this.convertCurrency(Number(invoice.subtotal || 0), invoice.currency, newCurrency, exchangeRate);
    const convertedTaxAmount = await this.convertCurrency(Number(invoice.taxAmount || 0), invoice.currency, newCurrency, exchangeRate);
    const convertedTotalAmount = await this.convertCurrency(Number(invoice.totalAmount || 0), invoice.currency, newCurrency, exchangeRate);

    return this.updateInvoice(invoiceId, {
      currency: newCurrency,
      exchangeRate: exchangeRate.toString(),
      subtotal: convertedSubtotal.toString(),
      taxAmount: convertedTaxAmount.toString(),
      totalAmount: convertedTotalAmount.toString(),
      outstandingAmount: convertedTotalAmount.toString()
    });
  }

  // PRICING & COSTING ENGINE OPERATIONS
  // Product Categories Management
  async getProductCategories(filters?: {
    parentCategoryId?: string;
    isActive?: boolean;
    limit?: number;
    offset?: number;
  }): Promise<ProductCategory[]> {
    let query = db.select().from(productCategories);
    
    const conditions = [];
    if (filters?.parentCategoryId !== undefined) {
      if (filters.parentCategoryId === null) {
        conditions.push(sql`${productCategories.parentCategoryId} IS NULL`);
      } else {
        conditions.push(eq(productCategories.parentCategoryId, filters.parentCategoryId));
      }
    }
    if (filters?.isActive !== undefined) {
      conditions.push(eq(productCategories.isActive, filters.isActive));
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    if (filters?.limit) query = query.limit(filters.limit);
    if (filters?.offset) query = query.offset(filters.offset);
    
    return query.orderBy(productCategories.name);
  }

  async getProductCategory(id: string): Promise<ProductCategory | undefined> {
    const [category] = await db.select().from(productCategories).where(eq(productCategories.id, id));
    return category;
  }

  async createProductCategory(categoryData: InsertProductCategory): Promise<ProductCategory> {
    const [category] = await db.insert(productCategories).values(categoryData).returning();
    await this.logAuditEvent("product_category", category.id, "create", undefined, undefined, category);
    return category;
  }

  async updateProductCategory(id: string, categoryData: Partial<InsertProductCategory>): Promise<ProductCategory> {
    const oldCategory = await this.getProductCategory(id);
    const [category] = await db
      .update(productCategories)
      .set({ ...categoryData, updatedAt: new Date() })
      .where(eq(productCategories.id, id))
      .returning();
    
    await this.logAuditEvent("product_category", id, "update", undefined, oldCategory, category);
    return category;
  }

  async deleteProductCategory(id: string): Promise<void> {
    const oldCategory = await this.getProductCategory(id);
    await db.delete(productCategories).where(eq(productCategories.id, id));
    await this.logAuditEvent("product_category", id, "delete", undefined, oldCategory, undefined);
  }

  // Markup Configuration Management
  async getMarkupConfigurations(filters?: {
    level?: string;
    entityId?: string;
    isActive?: boolean;
  }): Promise<MarkupConfiguration[]> {
    let query = db.select().from(markupConfiguration);
    
    const conditions = [];
    if (filters?.level) {
      conditions.push(eq(markupConfiguration.level, filters.level));
    }
    if (filters?.entityId) {
      conditions.push(eq(markupConfiguration.entityId, filters.entityId));
    }
    if (filters?.isActive !== undefined) {
      conditions.push(eq(markupConfiguration.isActive, filters.isActive));
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    return query.orderBy(desc(markupConfiguration.effectiveFrom));
  }

  async getMarkupConfiguration(id: string): Promise<MarkupConfiguration | undefined> {
    const [config] = await db.select().from(markupConfiguration).where(eq(markupConfiguration.id, id));
    return config;
  }

  async getActiveMarkupForEntity(level: string, entityId?: string): Promise<MarkupConfiguration | undefined> {
    const conditions = [
      eq(markupConfiguration.level, level),
      eq(markupConfiguration.isActive, true),
      sql`${markupConfiguration.effectiveFrom} <= NOW()`,
      sql`(${markupConfiguration.effectiveTo} IS NULL OR ${markupConfiguration.effectiveTo} > NOW())`
    ];
    
    if (entityId) {
      conditions.push(eq(markupConfiguration.entityId, entityId));
    } else {
      conditions.push(sql`${markupConfiguration.entityId} IS NULL`);
    }

    const [config] = await db
      .select()
      .from(markupConfiguration)
      .where(and(...conditions))
      .orderBy(desc(markupConfiguration.effectiveFrom))
      .limit(1);
    
    return config;
  }

  async createMarkupConfiguration(configData: InsertMarkupConfiguration): Promise<MarkupConfiguration> {
    const [config] = await db.insert(markupConfiguration).values(configData).returning();
    await this.logAuditEvent("markup_configuration", config.id, "create", configData.createdBy, undefined, config);
    return config;
  }

  async updateMarkupConfiguration(id: string, configData: Partial<InsertMarkupConfiguration>): Promise<MarkupConfiguration> {
    const oldConfig = await this.getMarkupConfiguration(id);
    const [config] = await db
      .update(markupConfiguration)
      .set({ ...configData, updatedAt: new Date() })
      .where(eq(markupConfiguration.id, id))
      .returning();
    
    await this.logAuditEvent("markup_configuration", id, "update", configData.updatedBy, oldConfig, config);
    return config;
  }

  // Item Pricing Management with Auto-Calculation
  async getItemPricing(itemId: string): Promise<ItemPricing | undefined> {
    const [pricing] = await db
      .select()
      .from(itemPricing)
      .where(and(
        eq(itemPricing.itemId, itemId),
        eq(itemPricing.isActive, true)
      ))
      .orderBy(desc(itemPricing.effectiveFrom))
      .limit(1);
    
    return pricing;
  }

  async getAllItemPricing(filters?: {
    isActive?: boolean;
    isManualOverride?: boolean;
    limit?: number;
    offset?: number;
  }): Promise<ItemPricing[]> {
    let query = db.select().from(itemPricing);
    
    const conditions = [];
    if (filters?.isActive !== undefined) {
      conditions.push(eq(itemPricing.isActive, filters.isActive));
    }
    if (filters?.isManualOverride !== undefined) {
      conditions.push(eq(itemPricing.isManualOverride, filters.isManualOverride));
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    if (filters?.limit) query = query.limit(filters.limit);
    if (filters?.offset) query = query.offset(filters.offset);
    
    return query.orderBy(desc(itemPricing.effectiveFrom));
  }

  async calculatePricesForItem(itemId: string, supplierCost: number): Promise<{
    retailPrice: number;
    wholesalePrice: number;
    retailMarkupPercentage: number;
    wholesaleMarkupPercentage: number;
  }> {
    // Get item details to find category
    const item = await this.getInventoryItem(itemId);
    if (!item) {
      throw new Error("Item not found");
    }

    // Hierarchy: Item > Category > System
    let retailMarkup = 70; // Default retail markup
    let wholesaleMarkup = 40; // Default wholesale markup

    // Check for item-specific markup
    const itemMarkup = await this.getActiveMarkupForEntity("Item", itemId);
    if (itemMarkup) {
      retailMarkup = parseFloat(itemMarkup.retailMarkupPercentage || "70");
      wholesaleMarkup = parseFloat(itemMarkup.wholesaleMarkupPercentage || "40");
    } else if (item.categoryId) {
      // Check for category-specific markup
      const categoryMarkup = await this.getActiveMarkupForEntity("Category", item.categoryId);
      if (categoryMarkup) {
        retailMarkup = parseFloat(categoryMarkup.retailMarkupPercentage || "70");
        wholesaleMarkup = parseFloat(categoryMarkup.wholesaleMarkupPercentage || "40");
      } else {
        // Use system-wide markup
        const systemMarkup = await this.getActiveMarkupForEntity("System");
        if (systemMarkup) {
          retailMarkup = parseFloat(systemMarkup.retailMarkupPercentage || "70");
          wholesaleMarkup = parseFloat(systemMarkup.wholesaleMarkupPercentage || "40");
        }
      }
    }

    // Calculate prices using the formula: Price = Cost / (1 - Markup%)
    const retailPrice = supplierCost / (1 - (retailMarkup / 100));
    const wholesalePrice = supplierCost / (1 - (wholesaleMarkup / 100));

    return {
      retailPrice: Math.round(retailPrice * 100) / 100,
      wholesalePrice: Math.round(wholesalePrice * 100) / 100,
      retailMarkupPercentage: retailMarkup,
      wholesaleMarkupPercentage: wholesaleMarkup,
    };
  }

  async createOrUpdateItemPricing(itemId: string, supplierCost: number, userId?: string, isManualOverride: boolean = false, overrideReason?: string): Promise<ItemPricing> {
    // Get current pricing for audit trail
    const oldPricing = await this.getItemPricing(itemId);
    
    // Calculate new prices
    const calculatedPrices = await this.calculatePricesForItem(itemId, supplierCost);
    
    // Create pricing data
    const pricingData: InsertItemPricing = {
      itemId,
      supplierCost: supplierCost.toString(),
      retailPrice: calculatedPrices.retailPrice.toString(),
      wholesalePrice: calculatedPrices.wholesalePrice.toString(),
      retailMarkupPercentage: calculatedPrices.retailMarkupPercentage.toString(),
      wholesaleMarkupPercentage: calculatedPrices.wholesaleMarkupPercentage.toString(),
      isManualOverride,
      overrideReason,
      currency: "USD",
      createdBy: userId,
      updatedBy: userId,
    };

    // Deactivate old pricing
    if (oldPricing) {
      await db
        .update(itemPricing)
        .set({ isActive: false, updatedAt: new Date() })
        .where(eq(itemPricing.id, oldPricing.id));
    }

    // Create new pricing
    const [newPricing] = await db.insert(itemPricing).values(pricingData).returning();

    // Log price change history
    await this.logPriceChange({
      itemId,
      changeType: isManualOverride ? "manual_override" : "cost_update",
      oldSupplierCost: oldPricing?.supplierCost ? parseFloat(oldPricing.supplierCost) : undefined,
      newSupplierCost: supplierCost,
      oldRetailPrice: oldPricing?.retailPrice ? parseFloat(oldPricing.retailPrice) : undefined,
      newRetailPrice: calculatedPrices.retailPrice,
      oldWholesalePrice: oldPricing?.wholesalePrice ? parseFloat(oldPricing.wholesalePrice) : undefined,
      newWholesalePrice: calculatedPrices.wholesalePrice,
      reason: overrideReason || "Supplier cost update",
      triggeredBy: isManualOverride ? "manual" : "system",
      userId,
    });

    await this.logAuditEvent("item_pricing", newPricing.id, "create", userId, oldPricing, newPricing);
    return newPricing;
  }

  async overrideItemPricing(itemId: string, retailPrice?: number, wholesalePrice?: number, reason?: string, userId?: string): Promise<ItemPricing> {
    const currentPricing = await this.getItemPricing(itemId);
    if (!currentPricing) {
      throw new Error("No current pricing found for item");
    }

    const newRetailPrice = retailPrice || parseFloat(currentPricing.retailPrice);
    const newWholesalePrice = wholesalePrice || parseFloat(currentPricing.wholesalePrice);
    const supplierCost = parseFloat(currentPricing.supplierCost);

    // Calculate implied markup percentages
    const retailMarkupPercentage = ((newRetailPrice - supplierCost) / newRetailPrice) * 100;
    const wholesaleMarkupPercentage = ((newWholesalePrice - supplierCost) / newWholesalePrice) * 100;

    // Deactivate current pricing
    await db
      .update(itemPricing)
      .set({ isActive: false, updatedAt: new Date() })
      .where(eq(itemPricing.id, currentPricing.id));

    // Create override pricing
    const pricingData: InsertItemPricing = {
      itemId,
      supplierCost: currentPricing.supplierCost,
      retailPrice: newRetailPrice.toString(),
      wholesalePrice: newWholesalePrice.toString(),
      retailMarkupPercentage: retailMarkupPercentage.toString(),
      wholesaleMarkupPercentage: wholesaleMarkupPercentage.toString(),
      isManualOverride: true,
      overrideReason: reason,
      currency: currentPricing.currency,
      createdBy: userId,
      updatedBy: userId,
    };

    const [newPricing] = await db.insert(itemPricing).values(pricingData).returning();

    // Log price change
    await this.logPriceChange({
      itemId,
      changeType: "manual_override",
      oldRetailPrice: parseFloat(currentPricing.retailPrice),
      newRetailPrice,
      oldWholesalePrice: parseFloat(currentPricing.wholesalePrice),
      newWholesalePrice,
      reason: reason || "Manual price override",
      triggeredBy: "manual",
      userId,
    });

    await this.logAuditEvent("item_pricing", newPricing.id, "override", userId, currentPricing, newPricing);
    return newPricing;
  }

  // Customer-Specific Pricing
  async getCustomerPricing(customerId: string, itemId?: string): Promise<CustomerPricing[]> {
    let query = db.select().from(customerPricing).where(
      and(
        eq(customerPricing.customerId, customerId),
        eq(customerPricing.isActive, true),
        sql`${customerPricing.validFrom} <= NOW()`,
        sql`(${customerPricing.validTo} IS NULL OR ${customerPricing.validTo} > NOW())`
      )
    );
    
    if (itemId) {
      query = query.where(eq(customerPricing.itemId, itemId));
    }
    
    return query.orderBy(customerPricing.itemId);
  }

  async createCustomerPricing(pricingData: InsertCustomerPricing): Promise<CustomerPricing> {
    const [pricing] = await db.insert(customerPricing).values(pricingData).returning();
    await this.logAuditEvent("customer_pricing", pricing.id, "create", pricingData.createdBy, undefined, pricing);
    return pricing;
  }

  async updateCustomerPricing(id: string, pricingData: Partial<InsertCustomerPricing>): Promise<CustomerPricing> {
    const oldPricing = await this.getCustomerPricingById(id);
    const [pricing] = await db
      .update(customerPricing)
      .set({ ...pricingData, updatedAt: new Date() })
      .where(eq(customerPricing.id, id))
      .returning();
    
    await this.logAuditEvent("customer_pricing", id, "update", pricingData.updatedBy, oldPricing, pricing);
    return pricing;
  }

  async getCustomerPricingById(id: string): Promise<CustomerPricing | undefined> {
    const [pricing] = await db.select().from(customerPricing).where(eq(customerPricing.id, id));
    return pricing;
  }

  // Price Lists Generation and Management
  async getPriceLists(filters?: {
    type?: string;
    customerId?: string;
    categoryId?: string;
    isActive?: boolean;
    limit?: number;
    offset?: number;
  }): Promise<PriceList[]> {
    let query = db.select().from(priceLists);
    
    const conditions = [];
    if (filters?.type) {
      conditions.push(eq(priceLists.type, filters.type));
    }
    if (filters?.customerId) {
      conditions.push(eq(priceLists.customerId, filters.customerId));
    }
    if (filters?.categoryId) {
      conditions.push(eq(priceLists.categoryId, filters.categoryId));
    }
    if (filters?.isActive !== undefined) {
      conditions.push(eq(priceLists.isActive, filters.isActive));
    }
    
    if (conditions.length > 0) {
      query = query.where(and(...conditions));
    }
    
    if (filters?.limit) query = query.limit(filters.limit);
    if (filters?.offset) query = query.offset(filters.offset);
    
    return query.orderBy(desc(priceLists.createdAt));
  }

  async getPriceList(id: string): Promise<PriceList | undefined> {
    const [priceList] = await db.select().from(priceLists).where(eq(priceLists.id, id));
    return priceList;
  }

  async generatePriceList(listData: InsertPriceList): Promise<PriceList> {
    // Create price list record
    const [priceList] = await db.insert(priceLists).values({
      ...listData,
      generatedAt: new Date(),
    }).returning();

    // Generate price list items based on type and criteria
    await this.generatePriceListItems(priceList.id, priceList.type, {
      customerId: priceList.customerId,
      categoryId: priceList.categoryId,
    });

    await this.logAuditEvent("price_list", priceList.id, "generate", listData.createdBy, undefined, priceList);
    return priceList;
  }

  async generatePriceListItems(priceListId: string, type: string, criteria: { customerId?: string; categoryId?: string }): Promise<void> {
    // Get items to include in price list
    let itemsQuery = db.select({
      id: inventoryItems.id,
      name: inventoryItems.name,
      sku: inventoryItems.sku,
      categoryId: inventoryItems.categoryId,
    }).from(inventoryItems).where(eq(inventoryItems.isActive, true));

    if (criteria.categoryId) {
      itemsQuery = itemsQuery.where(eq(inventoryItems.categoryId, criteria.categoryId));
    }

    const items = await itemsQuery;

    const priceListItems = [];
    for (const item of items) {
      // Get item pricing
      const itemPricing = await this.getItemPricing(item.id);
      if (!itemPricing) continue;

      let price = parseFloat(itemPricing.retailPrice);
      let effectivePrice = price;
      let discountPercentage = 0;

      // Determine price based on list type
      if (type === "wholesale") {
        price = parseFloat(itemPricing.wholesalePrice);
        effectivePrice = price;
      } else if (type === "custom" && criteria.customerId) {
        // Check for customer-specific pricing
        const customerSpecificPricing = await this.getCustomerPricing(criteria.customerId, item.id);
        if (customerSpecificPricing.length > 0) {
          const customerPrice = customerSpecificPricing[0];
          effectivePrice = parseFloat(customerPrice.specialPrice);
          discountPercentage = parseFloat(customerPrice.discountPercentage || "0");
        }
      }

      priceListItems.push({
        priceListId,
        itemId: item.id,
        price: price.toString(),
        effectivePrice: effectivePrice.toString(),
        discountPercentage: discountPercentage > 0 ? discountPercentage.toString() : undefined,
        minimumQuantity: 1,
      });
    }

    if (priceListItems.length > 0) {
      await db.insert(priceListItems).values(priceListItems);
    }
  }

  async getPriceListItems(priceListId: string): Promise<PriceListItem[]> {
    return db.select().from(priceListItems).where(eq(priceListItems.priceListId, priceListId));
  }

  // Price Change History and Audit
  async logPriceChange(changeData: {
    itemId: string;
    changeType: string;
    oldSupplierCost?: number;
    newSupplierCost?: number;
    oldRetailPrice?: number;
    newRetailPrice?: number;
    oldWholesalePrice?: number;
    newWholesalePrice?: number;
    reason?: string;
    triggeredBy: string;
    userId?: string;
  }): Promise<void> {
    await db.insert(priceChangeHistory).values({
      itemId: changeData.itemId,
      changeType: changeData.changeType,
      oldSupplierCost: changeData.oldSupplierCost?.toString(),
      newSupplierCost: changeData.newSupplierCost?.toString(),
      oldRetailPrice: changeData.oldRetailPrice?.toString(),
      newRetailPrice: changeData.newRetailPrice?.toString(),
      oldWholesalePrice: changeData.oldWholesalePrice?.toString(),
      newWholesalePrice: changeData.newWholesalePrice?.toString(),
      reason: changeData.reason,
      triggeredBy: changeData.triggeredBy,
      userId: changeData.userId,
    });
  }

  async getPriceChangeHistory(itemId?: string, limit?: number, offset?: number): Promise<PriceChangeHistory[]> {
    let query = db.select().from(priceChangeHistory);
    
    if (itemId) {
      query = query.where(eq(priceChangeHistory.itemId, itemId));
    }
    
    if (limit) query = query.limit(limit);
    if (offset) query = query.offset(offset);
    
    return query.orderBy(desc(priceChangeHistory.createdAt));
  }

  // Bulk Pricing Operations
  async createBulkPricingOperation(operationData: InsertBulkPricingOperation): Promise<BulkPricingOperation> {
    const [operation] = await db.insert(bulkPricingOperations).values(operationData).returning();
    await this.logAuditEvent("bulk_pricing_operation", operation.id, "create", operationData.createdBy, undefined, operation);
    return operation;
  }

  async processBulkMarkupUpdate(operationId: string, newRetailMarkup: number, newWholesaleMarkup: number, criteria?: { categoryId?: string }): Promise<void> {
    // Start bulk operation
    await db
      .update(bulkPricingOperations)
      .set({ 
        status: "processing",
        startedAt: new Date(),
      })
      .where(eq(bulkPricingOperations.id, operationId));

    try {
      // Get items to update
      let itemsQuery = db.select().from(inventoryItems).where(eq(inventoryItems.isActive, true));
      
      if (criteria?.categoryId) {
        itemsQuery = itemsQuery.where(eq(inventoryItems.categoryId, criteria.categoryId));
      }

      const items = await itemsQuery;
      let processedCount = 0;

      for (const item of items) {
        try {
          const currentPricing = await this.getItemPricing(item.id);
          if (currentPricing) {
            const supplierCost = parseFloat(currentPricing.supplierCost);
            
            // Calculate new prices with new markup
            const newRetailPrice = supplierCost / (1 - (newRetailMarkup / 100));
            const newWholesalePrice = supplierCost / (1 - (newWholesaleMarkup / 100));

            // Update pricing
            await this.createOrUpdateItemPricing(item.id, supplierCost, "system", false, "Bulk markup update");
            processedCount++;
          }
        } catch (error) {
          console.error(`Error updating pricing for item ${item.id}:`, error);
        }
      }

      // Complete operation
      await db
        .update(bulkPricingOperations)
        .set({ 
          status: "completed",
          completedAt: new Date(),
          processedItemsCount: processedCount,
          affectedItemsCount: items.length,
        })
        .where(eq(bulkPricingOperations.id, operationId));

    } catch (error) {
      // Mark operation as failed
      await db
        .update(bulkPricingOperations)
        .set({ 
          status: "failed",
          completedAt: new Date(),
          errorLog: error instanceof Error ? error.message : "Unknown error",
        })
        .where(eq(bulkPricingOperations.id, operationId));
      
      throw error;
    }
  }

  async getBulkPricingOperations(limit?: number, offset?: number): Promise<BulkPricingOperation[]> {
    let query = db.select().from(bulkPricingOperations);
    
    if (limit) query = query.limit(limit);
    if (offset) query = query.offset(offset);
    
    return query.orderBy(desc(bulkPricingOperations.createdAt));
  }

  // Dynamic Price Calculation for Quotes/Orders
  async calculateEffectivePrice(itemId: string, customerId?: string, customerType?: string, quantity?: number): Promise<{
    basePrice: number;
    effectivePrice: number;
    discountApplied: number;
    priceSource: string;
  }> {
    // Get standard pricing
    const itemPricing = await this.getItemPricing(itemId);
    if (!itemPricing) {
      throw new Error("No pricing found for item");
    }

    let basePrice = parseFloat(itemPricing.retailPrice);
    let effectivePrice = basePrice;
    let discountApplied = 0;
    let priceSource = "retail";

    // Check customer type for wholesale pricing
    if (customerType === "Wholesale") {
      basePrice = parseFloat(itemPricing.wholesalePrice);
      effectivePrice = basePrice;
      priceSource = "wholesale";
    }

    // Check for customer-specific pricing
    if (customerId) {
      const customerSpecificPricing = await this.getCustomerPricing(customerId, itemId);
      if (customerSpecificPricing.length > 0) {
        const customerPrice = customerSpecificPricing[0];
        
        // Check quantity constraints
        const minQty = customerPrice.minimumQuantity || 1;
        const maxQty = customerPrice.maximumQuantity;
        
        if ((!quantity || quantity >= minQty) && (!maxQty || !quantity || quantity <= maxQty)) {
          effectivePrice = parseFloat(customerPrice.specialPrice);
          discountApplied = basePrice - effectivePrice;
          priceSource = "customer_specific";
        }
      }
    }

    return {
      basePrice,
      effectivePrice,
      discountApplied,
      priceSource,
    };
  }

  async logAuditEvent(
    entityType: string,
    entityId: string,
    action: string,
    userId?: string,
    oldData?: any,
    newData?: any
  ): Promise<void> {
    await db.insert(auditLog).values({
      entityType,
      entityId,
      action,
      oldData,
      newData,
      userId,
    });
  }
}

// Import test storage
import { TestStorage } from './test-storage.js';

// Use test storage for testing purposes
export let storage: IStorage;

// Check if we should use test storage
const USE_TEST_STORAGE = process.env.NODE_ENV === 'development' && process.env.DATABASE_URL?.includes('invalid');

if (USE_TEST_STORAGE) {
  console.log('[STORAGE] Using test storage with mock data');
  storage = new TestStorage();
} else {
  console.log('[STORAGE] Using database storage');
  storage = new DatabaseStorage();
}
